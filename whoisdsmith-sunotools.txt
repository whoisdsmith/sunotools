Directory structure:
└── whoisdsmith-sunotools/
    ├── Grok.md
    ├── Suno Info.md
    ├── download_cover_art.js
    ├── extrctr.js
    ├── ids.py
    ├── index.js
    ├── info.js
    ├── json2md.py
    ├── json_analyzer.py
    ├── main.py
    ├── suno api.md
    ├── suno.js
    ├── suno.py
    ├── suno_downloader.py
    ├── sunomegathread.md
    ├── trimr.py
    ├── uniq.py
    ├── unique_songs.txt
    ├── url.txt
    ├── DL1/
    │   ├── README.md
    │   ├── getData.js
    │   ├── requirements.txt
    │   └── suno-downloader.py
    ├── DL2/
    │   ├── README.md
    │   ├── check_artwork.py
    │   ├── embed_artwork.py
    │   ├── get_metadata.py
    │   ├── get_suno.py
    │   ├── main.py
    │   ├── suno/
    │   │   ├── __init__.py
    │   │   ├── exceptions.py
    │   │   ├── fetch.py
    │   │   ├── processing.py
    │   │   └── .gitignore
    │   ├── tests/
    │   │   ├── __init__.py
    │   │   ├── test_check_artwork.py
    │   │   ├── test_embed_artwork.py
    │   │   ├── test_get_suno.py
    │   │   └── test_utils/
    │   │       ├── __init__.py
    │   │       ├── test_artwork_utils.py
    │   │       ├── test_fetch_utils.py
    │   │       ├── test_file_utils.py
    │   │       ├── test_metadata_utils.py
    │   │       └── test_url_utils.py
    │   └── utils/
    │       ├── __init__.py
    │       ├── artist_song_utils.py
    │       ├── artwork_utils.py
    │       ├── fetch_utils.py
    │       ├── file_utils.py
    │       ├── get_metadata_utils.py
    │       ├── logging_utils.py
    │       ├── metadata_utils.py
    │       ├── playlist_utils.py
    │       └── url_utils.py
    ├── DL3/
    │   ├── README.md
    │   ├── index.html
    │   ├── postcss.config.cjs
    │   ├── vite.config.ts
    │   ├── yarn.lock
    │   ├── docs/
    │   │   ├── index.htm
    │   │   └── style.css
    │   ├── public/
    │   │   └── assets/
    │   ├── src/
    │   │   ├── App.css
    │   │   ├── App.tsx
    │   │   ├── main.tsx
    │   │   ├── vite-env.d.ts
    │   │   ├── components/
    │   │   │   ├── Footer.tsx
    │   │   │   ├── SectionHeading.tsx
    │   │   │   └── StatusIcon.tsx
    │   │   ├── icons/
    │   │   ├── services/
    │   │   │   ├── RustFunctions.ts
    │   │   │   ├── Suno.ts
    │   │   │   └── Utils.ts
    │   │   └── styles/
    │   │       └── notifications.module.css
    │   └── src-tauri/
    │       ├── Cargo.lock
    │       ├── Cargo.toml
    │       ├── build.rs
    │       ├── .gitignore
    │       ├── icons/
    │       │   ├── icon.icns
    │       │   ├── android/
    │       │   │   ├── mipmap-hdpi/
    │       │   │   ├── mipmap-mdpi/
    │       │   │   ├── mipmap-xhdpi/
    │       │   │   ├── mipmap-xxhdpi/
    │       │   │   └── mipmap-xxxhdpi/
    │       │   └── ios/
    │       └── src/
    │           ├── lib.rs
    │           └── main.rs
    ├── DL4/
    │   ├── README.md
    │   └── get_suno.py
    └── SunoURLS/
        ├── sunoGFT.py
        ├── sunoGPX.js
        └── sunoREADME.md

================================================
File: Grok.md
================================================

# GrokSuno

To address your query, I've created a JavaScript script that parses a list of Suno.com song URLs and extracts detailed song and artist information, including the song title, artist name, lyrics, song ID, creation date, genre tags, cover image URL, and audio URL. The script then formats this information into nicely structured Markdown files, one for each song. Below is the complete solution, including explanations and instructions for use.

---

## Solution

### Overview

This script:

1. Accepts multiple Suno.com song URLs as command-line arguments.
2. Fetches the HTML content of each song page using `node-fetch`.
3. Extracts song metadata embedded in `<script>` tags using `node-html-parser`.
4. Parses the extracted JSON data to retrieve song details.
5. Extracts the song ID from the URL.
6. Formats the information into a Markdown file for each song, saved in a `songs` directory.

### Requirements

- __Node.js__: Ensure you have Node.js installed (version supporting ES modules, e.g., 14+).
- __Dependencies__: Install the required packages by running:

  ```bash
  npm install node-fetch node-html-parser
  ```

### Script Code

Create a file named `parseSunoSongs.js` and add the following code:

```javascript
import * as fs from 'fs/promises';
import fetch from 'node-fetch';
import { parse } from 'node-html-parser';

// Fetch HTML content from a URL
async function fetchPageContent(url) {
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`Failed to fetch ${url}: ${response.statusText}`);
    }
    return await response.text();
}

// Extract all script tags from HTML
function extractScriptTags(html) {
    const root = parse(html);
    return root.querySelectorAll('script');
}

// Find script tags containing Suno data (self.__next_f.push)
function findDataScripts(scriptTags) {
    return scriptTags.filter(script => script.text.includes('self.__next_f.push'));
}

// Extract JSON data and lyrics from script tags
function extractDataFromScripts(dataScripts) {
    let concatenatedData = '';
    let lyricsData = '';

    for (const script of dataScripts) {
        const match = script.text.match(/self\.__next_f\.push\(\[\d+,"(.*)"\]\)/s);
        if (match && match[1]) {
            const unescapedString = JSON.parse(`"${match[1]}"`);
            if (unescapedString.trim().startsWith('{"clip":')) {
                concatenatedData += unescapedString;
            } else {
                lyricsData += unescapedString + '\n';
            }
        }
    }

    return { concatenatedData, lyricsData };
}

// Parse JSON data from concatenated script content
function extractJsonData(concatenatedData) {
    const jsonStartIndex = concatenatedData.indexOf('{"clip":');
    if (jsonStartIndex === -1) {
        throw new Error('JSON data not found in script content.');
    }

    const jsonString = concatenatedData.slice(jsonStartIndex);
    try {
        return JSON.parse(jsonString);
    } catch (error) {
        const positionMatch = error.message.match(/at position (\d+)/);
        if (positionMatch) {
            return JSON.parse(jsonString.slice(0, parseInt(positionMatch[1])));
        }
        throw new Error('Failed to parse JSON data.');
    }
}

// Extract song information from JSON data
function extractSongInformation(jsonData) {
    const clip = jsonData.clip;
    return {
        title: clip.title || 'Unknown Title',
        artist: clip.display_name || 'Unknown Artist',
        coverImageUrl: clip.image_large_url || clip.image_url || 'No Image URL',
        creationDate: clip.created_at || 'Unknown Date',
        audioUrl: clip.audio_url || 'No Audio URL',
        tags: Array.isArray(clip.metadata.tags) ? clip.metadata.tags.join(', ') : clip.metadata.tags || 'No Tags'
    };
}

// Sanitize filenames to remove invalid characters
function sanitizeFileName(name) {
    return name.replace(/[<>:"/\\|?*]/g, '-');
}

// Save song details to a Markdown file
async function saveSongDetailsAsMarkdown(details) {
    const { title, artist, tags, lyrics, coverImageUrl, creationDate, audioUrl, songId } = details;

    const markdownContent = `
# ${title}

**Song ID:** ${songId}

![Cover Image](${coverImageUrl})

**Artist:** ${artist}
**Tags:** ${tags}
**Release Date:** ${creationDate}
**Cover Image Download:** [Download Image](${coverImageUrl})
**Audio Download:** [Download Audio](${audioUrl})

## Lyrics:
${lyrics}
    `;

    const sanitizedArtist = sanitizeFileName(artist);
    const sanitizedTitle = sanitizeFileName(title);
    const markdownFilename = `songs/${sanitizedArtist} - ${sanitizedTitle} - ${songId}.md`;

    await fs.mkdir('songs', { recursive: true });
    await fs.writeFile(markdownFilename, markdownContent.trim());
    console.log(`Saved: ${markdownFilename}`);
}

// Process a single URL
async function processURL(url) {
    try {
        const html = await fetchPageContent(url);
        const scriptTags = extractScriptTags(html);
        const dataScripts = findDataScripts(scriptTags);
        const { concatenatedData, lyricsData } = extractDataFromScripts(dataScripts);
        const jsonData = extractJsonData(concatenatedData);
        const songDetails = extractSongInformation(jsonData);
        songDetails.lyrics = lyricsData.trim() || 'Lyrics not available';
        songDetails.songId = url.split('/').pop();

        await saveSongDetailsAsMarkdown(songDetails);
    } catch (error) {
        console.error(`Error processing ${url}:`, error.message);
    }
}

// Main execution: process all URLs from command-line arguments
async function main() {
    const urls = process.argv.slice(2);
    if (urls.length === 0) {
        console.error('Please provide at least one Suno song URL.');
        process.exit(1);
    }

    for (const url of urls) {
        if (!url.match(/https:\/\/suno\.com\/song\/[0-9a-f-]{36}/)) {
            console.warn(`Skipping invalid URL: ${url}`);
            continue;
        }
        await processURL(url);
    }
}

main().catch(error => console.error('Script failed:', error));
```

---

## How to Use

### Running the Script

1. Save the script as `parseSunoSongs.js`.
2. Open a terminal in the script's directory.
3. Install dependencies:

   ```bash
   npm install node-fetch node-html-parser
   ```

4. Run the script with one or more Suno song URLs:

   ```bash
   node parseSunoSongs.js https://suno.com/song/12bfb381-df41-4452-9846-399e5e70153d https://suno.com/song/c0e77570-5f30-4482-a981-bd169f75432e
   ```

### Output

- For each valid URL, the script creates a Markdown file in the `songs` directory.
- Filename format: `Artist - Title - SongID.md` (e.g., `The Casket Diaries - Neon Lights & Lullabies - 12bfb381-df41-4452-9846-399e5e70153d.md`).
- Example Markdown content:

  ```
  # Neon Lights & Lullabies

  **Song ID:** 12bfb381-df41-4452-9846-399e5e70153d

  ![Cover Image](https://cdn2.suno.ai/image_large_c0e77570-5f30-4482-a981-bd169f75432e.jpeg)

  **Artist:** The Casket Diaries
  **Tags:** midwest emo, electronic
  **Release Date:** 2024-12-07T04:15:00Z
  **Cover Image Download:** [Download Image](https://cdn2.suno.ai/image_large_c0e77570-5f30-4482-a981-bd169f75432e.jpeg)
  **Audio Download:** [Download Audio](https://cdn1.suno.ai/12bfb381-df41-4452-9846-399e5e70153d.mp3)

  ## Lyrics:
  [Intro]
  [Verse 1]
  Neon lights flicker in the night...
  ```

- If a URL fails (e.g., invalid or network error), the script logs an error and continues with the next URL.

---

## Explanation of Extracted Information

| __Information__       | __Source__                         | __Notes__                                                                 |
|-----------------------|------------------------------------|---------------------------------------------------------------------------|
| __Song Title__        | JSON: `clip.title`                | Falls back to "Unknown Title" if missing.                                |
| __Artist Name__       | JSON: `clip.display_name`         | Falls back to "Unknown Artist" if missing.                               |
| __Lyrics__            | Script tags (non-JSON content)    | Collected from script text; "Lyrics not available" if none found.        |
| __Song ID__           | URL (last segment)                | Extracted from the URL path (e.g., `12bfb381-df41-4452-9846-399e5e70153d`). |
| __Date__              | JSON: `clip.created_at`           | ISO format (e.g., `2024-12-07T04:15:00Z`); "Unknown Date" if missing.    |
| __Genre Tags__        | JSON: `clip.metadata.tags`        | Joined with commas if an array; "No Tags" if missing.                    |
| __Cover Image URL__   | JSON: `clip.image_large_url` or `clip.image_url` | Direct link; "No Image URL" if missing.                  |
| __Audio URL__         | JSON: `clip.audio_url`            | Direct link; "No Audio URL" if missing. May require authentication.      |

---

## Notes and Limitations

- __Dynamic Content__: The script relies on data embedded in `<script>` tags (`self.__next_f.push`). If Suno changes how data is loaded (e.g., fully API-based), the script may need adjustment.
- __Audio URL Access__: The `audio_url` from the JSON is included as the download link. However, downloading may require authentication or adherence to Suno’s terms, depending on your account status.
- __Lyrics__: Extracted from script tags; may include extra text if not cleanly separated from other data. An alternative approach using HTML parsing (e.g., `<p>` with class `whitespace-pre-wrap`) could be implemented for precision.
- __Error Handling__: The script skips invalid URLs and logs errors without stopping execution.

---

This script fulfills your request by extracting all specified song information from Suno.com URLs and formatting it into readable Markdown files. Adjust the selectors or data extraction logic if Suno’s website structure changes. Let me know if you need further customization!

================================================
File: Suno Info.md
================================================

# SD Extraction

# __Report On Suno Website HTML Snippets (Developer Settings)__

__Source:__ HTML snippets copied from Suno website developer settings.

__Purpose of Analysis:__ To identify HTML elements containing playlist information and song information, and to understand the structure and potential functionality implied by these snippets.

__Findings:__

The analysis is divided into two main sections: Playlist Information and Song Information, corresponding to the two HTML snippets provided.

__Section 1: Playlist Information (Snippet 1)__

This snippet appears to represent the header section of a playlist page or component.

- __Playlist Container:__
  - The entire snippet is enclosed within a `<div>` with classes `css-i8pubi` and `data-theme="dark"`. This suggests a container element for the playlist information, styled with CSS and potentially part of a "dark theme" UI.

- __Playlist Cover Art:__
  - Element: `<img>`
  - Attributes:
    - `alt="Playlist cover art"`: Clearly identifies this image as the playlist's cover art.
    - `data-theme="dark"`: Indicates theme-specific styling.
    - `loading="lazy"`: Improves performance by lazy-loading the image.
    - `class="self-start css-cqmn0s"`: CSS classes for styling and layout.
    - `src="https://cdn2.suno.ai/image_12bfb381-df41-4452-9846-399e5e70153d.jpeg?width=360"`: The URL of the playlist cover art image. The `width=360` parameter likely controls image size.
  - __Information Conveyed:__ Displays the visual representation of the playlist.

- __Playlist Title and Description Area:__
  - Element: `<div>` with class `css-x8tmx8`
  - Contains:
    - __Playlist Title:__ `<h1>` tag with text "Remasters".
      - Classes: `font-serif font-light text-primary max-w-full line-clamp-1 break-all select-none whitespace-pre-wrap text-[28px] lg:text-[40px]` - Styling classes for font, size, text wrapping, and responsiveness.
      - __Information Conveyed:__ The name of the playlist ("Remasters").
    - __Playlist Description Button (Placeholder):__ `<div>` containing a `<button>` and `<span>` with text "Add playlist description".
      - Classes: Styling classes for layout and button appearance.
      - __Information Conveyed:__ Indicates a space to add a playlist description, currently a placeholder button.

- __Playlist Creator Information:__
  - Element: `<div>` with class `flex flex-row items-center gap-2`
  - Contains:
    - __Creator Avatar:__ `<div>` with nested `<a>` and `<img>`
      - `<a>` with `href="/@thecasketdiaries"` and `class="hover:underline block relative z-10 w-8 h-8"`: Link to the creator's profile.
      - `<img>` with `alt="Profile avatar"`, `data-src="https://cdn1.suno.ai/493a3c30.webp"`, `class="rounded-full w-full h-full object-cover p-1"`, `src="https://cdn1.suno.ai/493a3c30.webp"`: Displays the creator's profile picture.
    - __Creator Name:__ `<a>` with text "The Casket Diaries" and `href="/@thecasketdiaries"`.
      - Classes: `hover:underline line-clamp-1 max-w-fit break-all`, `title="The Casket Diaries"` - Styling and tooltip for the creator's name.
      - __Information Conveyed:__ Identifies the creator of the playlist ("The Casket Diaries") and links to their profile.
    - __Song Count:__ `<div>` with text "304 songs".
      - Classes: `line-clamp-1 text-ellipsis overflow-hidden w-fit` - Styling for text display and overflow handling.
      - __Information Conveyed:__ Indicates the number of songs in the playlist (304).

- __Playlist Controls and Actions:__
  - Element: `<div>` with class `css-ip6myw`
  - Contains:
    - __Privacy Toggle (Public/Private):__ `<button>` with nested `<span>` "Public" and a toggle switch structure (`<div>`s with classes related to switch styling).
      - __Information Conveyed:__ Shows the playlist's privacy status (currently "Public") and provides a toggle to change it.
    - __"Play" Button:__ `<button>` with nested `<svg>` play icon.
      - __Information Conveyed:__ Likely used to initiate playback of the entire playlist.
    - __"Share" Button:__ `<button>` with nested `<svg>` share icon.
      - __Information Conveyed:__ Used to share the playlist.
    - __"More Actions" Menu Button:__ `<button>` with `aria-label="More Actions"`, `id="menu-button-:remk:"`, and nested `<img>` for a "more actions" icon.
      - __Information Conveyed:__ Opens a menu for further actions related to the playlist (e.g., edit, delete, etc.).
      - __Menu Content (Hidden Initially):__ A `<div>` with class `css-1t6s810` and `style="visibility: hidden;"` containing a `<div>` with `role="menu"` and buttons for "Edit Details" and "Move to Trash". This is the dropdown menu that appears when "More Actions" is clicked.

__Section 2: Song Information (Snippet 2)__

This snippet represents a single row in a playlist song list.

- __Song Row Container:__
  - Element: `<div>` with classes `chakra-stack css-16pd6xq` and `data-theme="dark"`, `tabindex="0"`, `role="button"`, `data-clip-id="12bfb381-df41-4452-9846-399e5e70153d"`, `data-testid="song-row"`, `class="css-x08le3"`.
  - __Information Conveyed:__ Represents a clickable row for a song, likely interactive (tabindex, role="button"). `data-clip-id` strongly suggests this is the unique identifier for the song. `data-testid="song-row"` is for testing purposes.

- __Song Play Button and Image:__
  - Element: `<div>` with class `css-qayq89`
  - Contains:
    - __Play Button Area:__ `<div>` with `data-theme="dark"`, `aria-label="Play Song"`, `min-width="56px"`, `min-height="77px"`, `data-testid="song-row-play-button"`, `class="css-gj6ubv"`.
      - __Information Conveyed:__ Clickable area to play the specific song.
    - __Song Duration Display:__ `<span>` with song duration "3:10" and styling classes.
      - __Information Conveyed:__ Displays the length of the song.
    - __Song Image/Cover Art:__ `<img>` with `alt="Song Image"`, `data-theme="dark"`, `loading="lazy"`, `class="chakra-image css-umyjtf"`, `flex-shrink="0"`, `src="https://cdn2.suno.ai/image_12bfb381-df41-4452-9846-399e5e70153d.jpeg"`.
      - __Information Conveyed:__ Visual representation of the song. Uses the same image URL as the playlist cover art in this example, but could be different.
    - __Play Icon (Hidden Initially):__ `<div>` with `aria-label="Play"`, `class="absolute inset-0 flex justify-center items-center text-white transition-colors duration-200 opacity-0"` and nested `<svg>` play icon.
      - __Information Conveyed:__ Play icon that likely becomes visible on hover or interaction.

- __Song Title and Version Information:__
  - Element: `<div>` with class `css-79jxux`
  - Contains:
    - __Song Title Link:__ `<div>` with nested `<span>` and `<a>`.
      - `<span>` with `class="font-sans text-base font-medium line-clamp-1 break-all text-primary"`, `title="The Devil Wears a Hoodie (Remastered)"`: Styling and tooltip for the song title.
      - `<a>` with `href="/song/12bfb381-df41-4452-9846-399e5e70153d"` and nested `<span>` with text "The Devil Wears a Hoodie (Remastered)".
      - __Information Conveyed:__ The title of the song ("The Devil Wears a Hoodie (Remastered)") and a link to the song's individual page.
    - __Song Version Badge:__ `<div>` with nested `<span>` "v4".
      - Classes: Styling classes for badge appearance (background, border, text color).
      - __Information Conveyed:__ Indicates the version of the song (version 4).

- __Song Artist/Uploader Information:__
  - Element: `<div>` with class `flex`
  - Contains:
    - __Artist Avatar:__ `<div>` with nested `<img>` (similar structure to playlist creator avatar).
    - __Artist Name Link:__ `<div>` with nested `<a>` with text "The Casket Diaries" and `href="/@thecasketdiaries"`.
      - __Information Conveyed:__ Identifies the artist/uploader ("The Casket Diaries") and links to their profile.

- __Song Genres/Styles:__
  - Element: `<div>` with class `chakra-stack css-1f0wxn3`
  - Contains: `<div>` with multiple nested `<a>` tags, each representing a genre (e.g., "emo", "ambient", "rock", "electronic") and linking to the style page (`href="/style/emo"`).
  - __Information Conveyed:__ Displays the genres or styles associated with the song, providing links to explore songs of similar styles.

- __Song Actions and Controls (Right Side of Row):__
  - Element: `<div>` with class `css-1b0cg3t` and nested `<div>` with `css-1hohgv6` (repeated).
  - Contains:
    - __Like/Dislike Buttons:__ `<button>` elements with SVG icons for like and dislike.
    - __Share Button:__ `<button>` with SVG share icon.
    - __"More Actions" Menu Button:__ `<button>` with `aria-label="More Actions"`, `id="menu-button-:rfvr:"`, and nested `<span>` with SVG "more actions" icon.
    - __"Extend" Button:__ `<button>` with text "Extend". Purpose unclear from snippet alone, might relate to song length extension features.
    - __"Public" Toggle Button:__ `<button>` with text "Public" and a toggle switch structure (similar to playlist privacy toggle, but likely for individual song privacy).
    - __Like/Dislike Buttons (Duplicated?):__ Another set of like/dislike buttons. This duplication might be a UI redundancy or for different contexts/states.
    - __Comment Link:__ `<a>` with `href="/song/12bfb381-df41-4452-9846-399e5e70153d?show_comments=true"` and nested `<svg>` comment icon and `<span>` with comment count "0". Links to the song page with comments shown.
    - __Share Button (Duplicated?):__ Another share button.
    - __"More Options" Button:__ `<button>` with `id="radix-:rfvv:"`, `data-state="closed"`, `aria-label="More Options"` and nested `<span>` with SVG "more options" icon. Likely another menu for song-specific actions.

- __"Extend" and "Public" Buttons (Left Side of Row):__
  - Element: `<div>` with class `css-1kcq9v9`
  - Contains: "Extend" and "Public" buttons, seemingly duplicated from the right side actions, but positioned differently in the layout.

__Overall Observations and Conclusions:__

- __Semantic HTML:__ The snippets use semantic HTML elements (`<h1>`, `<img>`, `<a>`, `<button>`) with appropriate `alt` attributes and `aria-label` for accessibility, indicating good web development practices.
- __CSS Styling:__ Extensive use of CSS classes (`css-`, `chakra-`) suggests a component-based UI framework (likely Chakra UI or similar) is being used for styling and layout.
- __Data Attributes:__ `data-theme`, `data-clip-id`, `data-testid`, `data-src` attributes are used to store data related to theme, song ID, testing, and image sources.
- __Interactive Elements:__ Buttons and links are prevalent, indicating a highly interactive user interface for playlist and song management.
- __Dynamic Content:__ The use of `data-src` and image URLs from `cdn2.suno.ai` and `cdn1.suno.ai` points to dynamic loading of content from a content delivery network.
- __JavaScript Functionality:__ The interactive elements (buttons, toggles, menus) strongly imply JavaScript is used to handle user interactions, update UI state, and likely manage song playback and other functionalities.
- __No Direct Song Links:__ As previously noted, there are no direct HTML tags containing links to the actual song audio files (.mp3, .wav, etc.) in these snippets. Song playback is likely managed dynamically through JavaScript and backend APIs.
- __Component-Based Architecture:__ The structure and class naming suggest a component-based frontend architecture where UI elements are modular and reusable.
- __Focus on Metadata and UI:__ The snippets primarily focus on displaying metadata about playlists and songs and providing UI elements for user interaction. The actual audio streaming and backend logic are abstracted away from these HTML snippets.

__Recommendations for Further Investigation:__

- __Inspect JavaScript Code:__ Examine the JavaScript code associated with these elements (especially event listeners on buttons) to understand how user interactions are handled and how song playback is initiated.
- __Monitor Network Requests:__ Use browser developer tools (Network tab) to observe network requests made when interacting with these elements. This can reveal API calls and data exchanged with the backend, potentially including song streaming URLs or playback instructions.
- __Explore Full Page Source:__ Analyze the complete HTML source of a playlist page on the Suno website for a broader context and to identify any `<audio>` or `<video>` elements that might be used for playback (though they are likely dynamically created by JavaScript).

---

__Here's a breakdown of the findings, section by section:__

__1. Song Cover Image:__

```html
<div class="relative w-[200px] aspect-[2/3] rounded-xl overflow-hidden shrink-0 after:hidden after:absolute after:inset-x-0 after:bottom-0 after:h-1/6 after:bg-gradient-to-t cursor-pointer max-md:w-full max-md:aspect-square max-md:min-h-[360px] max-md:rounded-none max-md:-mb-44 max-md:after:block max-md:after:h-64 after:from-vinylBlack-darker"><img alt="Song Cover Image" data-src="https://cdn2.suno.ai/image_large_c0e77570-5f30-4482-a981-bd169f75432e.jpeg" class="block w-full h-full cursor-pointer object-cover" src="https://cdn2.suno.ai/image_large_c0e77570-5f30-4482-a981-bd169f75432e.jpeg"></div>
```

- __Cover Image:__
  - Tag: `<img>`
  - Attributes:
    - `alt="Song Cover Image"`: Identifies this as the song's cover image.
    - `data-src="https://cdn2.suno.ai/image_large_c0e77570-5f30-4482-a981-bd169f75432e.jpeg"`: URL for the large version of the cover image (likely for higher resolution displays or loading).
    - `class="block w-full h-full cursor-pointer object-cover"`: CSS classes for styling.
    - `src="https://cdn2.suno.ai/image_large_c0e77570-5f30-4482-a981-bd169f75432e.jpeg"`: URL for the cover image itself.
  - __Information:__ __Cover Image URL__

__2. Song Title Input and Artist Info:__

```html
<div class="relative flex-1 flex flex-col gap-2 self-stretch max-md:px-4"><div class="focus-within:[&amp;>input]:border-primary w-full font-serif font-light text-primary text-[40px]/[56px]"><input class="block w-full disabled:cursor-auto text-inherit font-inherit leading-inherit tracking-inherit border-b-2 border-transparent bg-transparent outline-none hover:cursor-pointer focus:cursor-text overflow-hidden text-ellipsis whitespace-nowrap" type="text" value="Neon Lights &amp; Lullabies"></div><div class="flex flex-row items-center justify-start gap-4"><div class="flex flex-row items-center gap-2 font-sans font-medium text-sm text-primary"><div class="relative flex-shrink"><a class="hover:underline block w-8 h-8" href="/@thecasketdiaries"><img data-src="https://cdn1.suno.ai/493a3c30.webp" class="rounded-full w-full h-full object-cover" src="https://cdn1.suno.ai/493a3c30.webp"></a></div><div class="relative flex-1"><a class="hover:underline line-clamp-1 max-w-fit break-all" href="/@thecasketdiaries">The Casket Diaries</a></div></div></div>
```

- __Song Title:__
  - Tag: `<input type="text">`
  - Attribute:
    - `value="Neon Lights &amp; Lullabies"`: Contains the song title. Note the HTML entity `&amp;` for "&".
  - __Information:__ __Song Title__ ("Neon Lights & Lullabies")

- __Artist Name and Link:__
  - Tag: `<a>` (nested within divs)
  - Attributes:
    - `href="/@thecasketdiaries"`: Link to the artist's profile.
  - Text Content: "The Casket Diaries"
  - __Information:__ __Artist Name__ ("The Casket Diaries") and __Artist Profile Link__ (`/@thecasketdiaries`)

- __Artist Avatar:__
  - Tag: `<img>` (nested within `<a>` and divs)
  - Attributes:
    - `data-src="https://cdn1.suno.ai/493a3c30.webp"`: URL for the artist avatar image.
    - `src="https://cdn1.suno.ai/493a3c30.webp"`: URL for the artist avatar image.
  - __Information:__ __Artist Avatar Image URL__

__3. Song Tags (Genres/Styles):__

```html
<div class="font-sans break-all gap-2 text-sm text-lightGray"><a class="hover:underline text-primary" title="midwest emo" href="/style/midwest%20emo">midwest emo</a>, <a class="hover:underline text-primary" title="electronic" href="/style/electronic">electronic</a>, ... </div>
```

- __Song Tags/Genres:__
  - Tags: `<a>` (multiple within a `<div>`)
  - Attributes (for each `<a>` tag):
    - `href="/style/[style_name]"`: Link to the style/genre page (e.g., `/style/midwest%20emo`).
    - `title="[style_name]"`: Tooltip text showing the style/genre name.
  - Text Content (for each `<a>` tag): Style/genre names (e.g., "midwest emo", "electronic", "djent", etc.)
  - __Information:__ __Song Tags/Genres__ (midwest emo, electronic, djent, ambient, pop emo, sad, female vocal) and __Links to Style Pages__.

__4. Date/Time and Version:__

```html
<div class="flex flex-row items-center justify-start gap-2"><span class="text-secondary text-sm" title="December 7, 2024 at 4:15 AM">December 7, 2024 at 4:15 AM</span><span class="text-xs font-medium font-sans border bg-tertiary rounded-md py-[3px] px-[6px] flex flex-row items-center text-nowrap text-green-300 border-green-300/60 mb-0">v4</span></div>
```

- __Date/Time:__
  - Tag: `<span>` (first one)
  - Attributes:
    - `title="December 7, 2024 at 4:15 AM"`: Tooltip with the full date and time.
  - Text Content: "December 7, 2024 at 4:15 AM"
  - __Information:__ __Song Creation Date and Time__

- __Version:__
  - Tag: `<span>` (second one)
  - Text Content: "v4"
  - __Information:__ __Song Version__ (v4)

__5. Lyrics Section:__

```html
<div class="px-6 md:px-0 w-full flex-1 pb-48"><div class="flex flex-row gap-4"><div class="flex-1"><section class="w-full flex flex-col gap-2 xl:pr-8"><div class="font-sans text-primary"><textarea class="p-4 rounded-lg whitespace-pre-wrap w-full h-full resize-none outline-none ease-linear transition font-sans text-inherit bg-tertiary border-2 hidden border-transparent" maxlength="7500" style="height: 1356px !important;">[Intro]

[Verse 1]
... (Lyrics Content) ...
[End]</textarea><p class="whitespace-pre-wrap">[Intro]

[Verse 1]
... (Lyrics Content - Duplicated) ...
[End]</p></div>
```

- __Lyrics:__
  - Tags:
    - `<textarea>`: Contains the lyrics, but is initially `hidden` (class `hidden`). This might be used for editing lyrics.
    - `<p>`: Contains a __duplicate__ of the lyrics and is visible. This is the element displaying the lyrics.
  - Text Content (within `<p>`): The full lyrics of the song.
  - __Information:__ __Song Lyrics__

__6. Playback UI (Audio Player at the Bottom):__

```html
<div class="w-[calc(100%-32px)] absolute bottom-0 ml-4 mr-4 rounded-none lg:rounded-lg xl:rounded-lg bg-transparent z-50  "><div class="w-full md:pb-5 bottom-0 h-auto z-5 min-w-[300px] rounded-t-xl"><audio id="active-audio-play"></audio><audio id="silent-audio" src="https://cdn1.suno.ai/sil-1s.mp3"></audio>...</div>
```

- __Audio Player Elements:__
  - Tags: `<audio>` (two instances)
    - `<audio id="active-audio-play"></audio>`: Likely the main audio player element, but __no `src` attribute__ pointing to a song file.
    - `<audio id="silent-audio" src="https://cdn1.suno.ai/sil-1s.mp3"></audio>`: An audio element with `src="https://cdn1.suno.ai/sil-1s.mp3"`. This is a __silent audio file__, probably used for background audio or as a placeholder/fallback.
  - __Information:__ __UI elements for audio playback__ are present (`<audio>` tags), but __no direct links to the actual song audio files (.mp3, .wav, etc.) are found directly within these HTML tags.__

__Summary Table of Song Information and HTML Elements:__

| Song Information        | HTML Element(s)                                 | Key Attributes/Text Content                                                                                                    |
| :---------------------- | :---------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------- |
| __Lyrics__              | `<p>`, `<textarea>` (hidden)                    | Text content within `<p>` and `<textarea>` tags.                                                                               |
| __Title__               | `<input type="text">`                           | `value` attribute                                                                                                              |
| __Artist Name__         | `<a>` (nested)                                   | Text content, `href` attribute for profile link                                                                                 |
| __Artist Profile Link__ | `<a>` (nested)                                   | `href` attribute                                                                                                               |
| __Artist Avatar Image URL__ | `<img>` (nested)                                  | `data-src`, `src` attributes                                                                                                 |
| __Cover Image URL__       | `<img>`                                         | `data-src`, `src` attributes                                                                                                 |
| __Song Tags/Genres__    | Multiple `<a>` tags within a `<div>`            | Text content (tag name), `href` attribute for style page link, `title` attribute for tooltip.                               |
| __Song Creation Date/Time__ | `<span>`                                        | Text content, `title` attribute for full date/time tooltip                                                                     |
| __Song Version__        | `<span>`                                        | Text content (e.g., "v4")                                                                                                     |
| __Audio Links__         | `<audio id="active-audio-play">`, `<audio id="silent-audio">` |  `<audio id="silent-audio"` has `src="https://cdn1.suno.ai/sil-1s.mp3"`. __No direct links to song files found for actual playback.__ |

__Key Takeaway regarding Audio Links:__

As in the previous snippets, __there are still no direct HTML tags in this more detailed snippet that provide links to the actual song files (like `.mp3`, `.wav`) for playback.__ The `<audio>` tags are present for the player UI, but the `src` for the main player (`active-audio-play`) is empty.  This reinforces the idea that the song URLs are handled dynamically by JavaScript, likely fetched from an API when playback is initiated, and not directly embedded in the HTML source.

---

## Suno.com HTML Elements for Song and Artist Information: Detailed Report

This report details the HTML elements identified from Suno.com snippets and analysis that are likely to contain song and artist information. It covers lyrics, song ID, song name, artist name, date, genre tags, cover images, and URLs for cover images and audio downloads.

__Report Structure:__

For each information category, this report will outline:

- __Information Type:__ The specific data being discussed (e.g., Song Title).
- __HTML Element(s):__ The HTML tag(s) likely used to represent this information.
- __Key Attributes:__ Important attributes of the HTML element that contain or link to the data.
- __Example Content/Value:__ Illustrative text or URL values based on the provided snippets.
- __Notes/Observations:__ Additional context, caveats, and how the information is likely handled (e.g., dynamic content, JavaScript interaction).

---

__1. Song Title__

- __Information Type:__ Song Title
- __HTML Element(s):__
  - `<input type="text">` (Likely for editable titles, e.g., in edit mode)
  - `<span>` or `<a>` (For display in song lists, playbars, etc.)
- __Key Attributes:__
  - `<input type="text">`: `value` attribute (contains the title text)
  - `<span>`/`<a>`: Text content of the tag. `title` attribute might be used for tooltip. `href` attribute if the title is a link to the song page.
- __Example Content/Value:__ "Neon Lights & Lullabies", "The Devil Wears a Hoodie (Remastered)"
- __Notes/Observations:__
  - The `<input type="text">` element from the larger snippet suggests editable song titles.
  - `<span>` or `<a>` tags in song lists (like in Snippet 2) are used for display and linking to song-specific pages.
  - Titles are styled using CSS classes (e.g., `font-sans`, `text-base`, `font-medium`, `line-clamp-1`).

__2. Artist Name__

- __Information Type:__ Artist Name (or Uploader Name)
- __HTML Element(s):__ `<a>` (Likely always a link to the artist's profile)
- __Key Attributes:__
  - `href`: Attribute containing the link to the artist's profile page (e.g., `/@thecasketdiaries`).
  - `title`: Attribute may contain the full artist name for tooltip.
- __Example Content/Value:__ "The Casket Diaries", `href="/@thecasketdiaries"`
- __Notes/Observations:__
  - Artist names are consistently represented as links (`<a>` tags) to their profiles.
  - Artist avatars (`<img>` tags) are often associated with the artist name `<a>` tag.
  - Styling classes are used for text and link appearance (e.g., `hover:underline`, `line-clamp-1`, `max-w-fit`).

__3. Song Lyrics__

- __Information Type:__ Song Lyrics
- __HTML Element(s):__
  - `<textarea>` (Potentially for editable lyrics, often hidden initially)
  - `<p>` (For displayed lyrics)
- __Key Attributes:__
  - `<textarea>`/`<p>`: Text content within the tags holds the lyric text.
  - `<textarea>`: May have attributes like `maxlength`, `style` (for height), `class` for styling.
- __Example Content/Value:__ The full lyrics text from the larger snippet, including verse markers like "[Verse 1]", "[Chorus]", etc.
- __Notes/Observations:__
  - Lyrics are present in both `<textarea>` and `<p>` elements in the larger snippet. The `<textarea>` is initially hidden, suggesting it's for editing and the `<p>` for display.
  - Lyrics are formatted with whitespace preservation (`whitespace-pre-wrap` class or style).

__4. Genre Tags (Song Tags/Styles)__

- __Information Type:__ Genre Tags, Style Tags
- __HTML Element(s):__ Multiple `<a>` tags, typically within a `<div>` container.
- __Key Attributes:__
  - `href`: Attribute linking to the style/genre page (e.g., `/style/midwest%20emo`).
  - `title`: Attribute containing the full genre/style name for tooltip.
- __Example Content/Value:__ "midwest emo", "electronic", "djent", "ambient", "pop emo", "sad", "female vocal"; `href="/style/midwest%20emo"`, `href="/style/electronic"`, etc.
- __Notes/Observations:__
  - Genre/style tags are presented as a comma-separated list of links (`<a>` tags).
  - Each tag links to a style-specific page on Suno.com.
  - Styling classes are used for text appearance (e.g., `hover:underline`, `text-primary`).

__5. Song Creation Date/Time__

- __Information Type:__ Song Creation Date and Time
- __HTML Element(s):__ `<span>`
- __Key Attributes:__
  - `title`: Attribute often contains the full, detailed date and time information.
- __Example Content/Value:__ "December 7, 2024 at 4:15 AM", `title="December 7, 2024 at 4:15 AM"`
- __Notes/Observations:__
  - The date and time are displayed in a `<span>` tag.
  - The `title` attribute provides a tooltip with the full date and time, while the text content might be a more human-friendly format (though in this case, they are the same).

__6. Song Version__

- __Information Type:__ Song Version (e.g., v4)
- __HTML Element(s):__ `<span>`
- __Key Attributes:__ None specifically for the version number itself, styling classes are used.
- __Example Content/Value:__ "v4"
- __Notes/Observations:__
  - Song version is displayed as simple text within a `<span>` tag.
  - Styling classes are used to create a badge-like appearance (e.g., `text-xs`, `font-medium`, `font-sans`, `border`, `bg-tertiary`, `rounded-md`).

__7. Cover Image__

- __Information Type:__ Song Cover Image
- __HTML Element(s):__ `<img>`
- __Key Attributes:__
  - `alt`: Attribute describing the image content (e.g., "Song Cover Image", "Cover image for Neon Lights & Lullabies").
  - `data-src`: Attribute often contains the URL for a larger or higher-resolution version of the image.
  - `src`: Attribute containing the URL of the cover image itself.
- __Example Content/Value:__ `alt="Song Cover Image"`, `data-src="https://cdn2.suno.ai/image_large_c0e77570-5f30-4482-a981-bd169f75432e.jpeg"`, `src="https://cdn2.suno.ai/image_large_c0e77570-5f30-4482-a981-bd169f75432e.jpeg"`
- __Notes/Observations:__
  - `<img>` tags are used to display cover images in various contexts (song lists, playbar, song pages).
  - Often, both `data-src` and `src` attributes are present, potentially for lazy loading or responsive image handling, with `data-src` pointing to a larger version.
  - `alt` attributes are consistently used for accessibility.

__8. Cover Image URL (Direct URL to Image File)__

- __Information Type:__ URL to Download/Access the Cover Image File
- __HTML Element(s):__ Attribute of the `<img>` tag.
- __Key Attributes:__
  - `src`: The `src` attribute of the `<img>` tag directly provides the URL to the cover image file.
  - `data-src`: The `data-src` attribute may also contain a URL, often for a larger version.
- __Example Content/Value:__ `https://cdn2.suno.ai/image_large_c0e77570-5f30-4482-a981-bd169f75432e.jpeg` (from `src` and `data-src` attributes of the `<img>` tag).
- __Notes/Observations:__
  - The `src` and `data-src` attributes of the `<img>` tag are the elements that directly contain the URLs to the cover image files.
  - These URLs are typically on Suno's CDN (Content Delivery Network) like `cdn2.suno.ai`.

__9. Audio Download URLs (Direct URLs to Audio Files - MP3, M4A, WAV)__

- __Information Type:__ URLs to Download Audio Files (MP3, M4A, WAV)
- __HTML Element(s):__ `<a>` tags within a download menu (as deduced in previous reports).
- __Key Attributes:__
  - `href`: Attribute of the `<a>` tag. This is __hypothesized__ to contain the download URL when the download menu is active and download options are presented.
- __Example Content/Value:__ Likely dynamic URLs that would be generated on demand and might look something like:
  - `https://suno.com/download/[song_id].mp3`
  - `https://suno.com/download/[song_id].m4a`
  - `https://suno.com/download/[song_id].wav` (for Pro/Premier plans)
  - __Note:__ These are *example* URLs and might not be the exact format used by Suno.
- __Notes/Observations:__
  - __Crucially, direct audio download URLs are *not* expected to be found directly embedded in the HTML source in page load.__ They are dynamically generated and likely appear *only* when the download menu is triggered and the user is authorized to download.
  - The `<a>` tags for download options ("Download Audio (mp3)", "Download Video (m4a)", "Download Audio (wav)") within the triple-dot menu are the hypothesized HTML elements containing these dynamic download URLs in their `href` attributes.
  - The format and availability of download options (MP3, M4A, WAV) depend on the user's subscription plan.

__10. Song ID__

- __Information Type:__ Unique Song Identifier (Song ID)
- __HTML Element(s):__
  - `data-clip-id` attribute on container elements (e.g., `<div>` for song row in a playlist)
  - Part of URLs in `<a>` tag `href` attributes (e.g., `/song/[song_id]`, `/download/[song_id].mp3`)
- __Key Attributes:__
  - `data-clip-id`: Attribute value directly contains the Song ID.
  - `href`: URLs in `href` attributes embed the Song ID as part of the path.
- __Example Content/Value:__ `12bfb381-df41-4452-9846-399e5e70153d`, `c0e77570-5f30-4482-a981-bd169f75432e`, `a5e2198a-f352-4abb-9a24-7f81b143ded3`
- __Notes/Observations:__
  - Song IDs are used extensively throughout the HTML as identifiers for songs.
  - They appear in `data-clip-id` attributes, likely for JavaScript to easily access the ID associated with a song element.
  - They are also embedded in URLs for song pages (`/song/[song_id]`) and potentially download URLs (`/download/[song_id].mp3`).

---

### Answer to User Query: Extracting and Downloading Songs from a Suno.com User's Song Library

Yes, the provided scripts and tools contain functionality to extract all songs from a Suno.com user's song library, with specific capabilities tailored to different access methods (playlists and artist pages). Below, I'll detail how these tools achieve this, focusing primarily on the two most relevant projects: the __Suno Music Downloader__ (a Tauri app under `Sunodownloader/`) and the __Sunodl__ Python scripts. These tools address the query by extracting song data from playlists and artist pages, respectively, and downloading the associated files.

---

#### __1. Suno Music Downloader (Tauri App)__

The __Suno Music Downloader__, located in the `Sunodownloader/` directory, is a desktop application built with Tauri and React that excels at downloading entire playlists from Suno.com. Here's how it works:

- __Getting Links from a Playlist:__
  - __User Input:__ The process begins in `src/App.tsx` with the `getPlaylist` function. Users paste a playlist URL (e.g., `https://suno.com/playlist/8ebe794f-d640-46b6-bde8-121622e1a4c2`) into a text input field and click "Get playlist songs."
  - __Playlist ID Extraction:__ The `Suno.getSongsFromPlayList` method in `src/services/Suno.ts` extracts the playlist ID from the URL using a regex pattern: `/suno\.com\/playlist\/(.*)/`. For the example URL, it retrieves `8ebe794f-d640-46b6-bde8-121622e1a4c2`.
  - __API Fetching:__ It then fetches playlist data from Suno's API endpoint: `https://studio-api.prod.suno.com/api/playlist/{playlistId}/?page={currentPage}`. The method paginates through all pages (incrementing `currentPage`) until no more songs are returned (`data.playlist_clips.length == 0`), collecting metadata for each song clip.
  - __Song Data:__ Each clip's data (e.g., `id`, `title`, `audio_url`, `image_url`, etc.) is stored in an `IPlaylistClip` array, alongside playlist metadata (`name`, `image`) in an `IPlaylist` object.

- __Downloading Songs:__
  - __Initiation:__ After fetching the playlist data, clicking "Download songs" triggers the `downloadPlaylist` function in `src/App.tsx`.
  - __Directory Setup:__ It creates an output directory named after the playlist (e.g., `{saveFolder}/{playlistName}`) and a temporary folder (`tmp`) using `ensureDir` from `RustFunctions.ts`.
  - __Parallel Downloads:__ Using the `p-limit` library (set to 5 concurrent downloads), it processes each song:
    - __Audio Download:__ Fetches the song's `audio_url` (e.g., `https://cdn1.suno.ai/{songId}.mp3`) and writes it to `{outputDir}/{songNo} - {songTitle}.mp3` using `writeFile`.
    - __Cover Art:__ Optionally fetches the `image_url`, saves it temporarily (e.g., `tmp/{songId}.jpg`), and embeds it into the MP3 using `addImageToMp3` from `RustFunctions.ts`.
  - __Cleanup:__ After all downloads complete, the temporary folder is deleted with `deletePath`.
  - __Progress Tracking:__ The UI updates with download progress (via `setDownloadPercentage`) and status icons (via `updateClipStatus`).

- __Relevance to Song Library:__ While optimized for playlists, this tool can extract a user's entire song library __if__ the user creates a playlist containing all their songs (e.g., a "My Songs" playlist). Without such a playlist, it doesn't directly access the full library.

---

#### __2. Sunodl (Python Scripts)__

The __Sunodl__ project, located in the `Sunodl/` directory, offers a more versatile solution, particularly for extracting songs directly from a user's artist page (e.g., `https://suno.com/@username`), which typically lists all songs created by that user. Here's how it accomplishes this:

- __Getting Links from an Artist Page:__
  - __User Input:__ In `main.py`, the "Download Artist Collection" option (choice `7`) prompts the user to enter an artist page URL.
  - __Processing URLs:__ The `process_urls` function in `suno/processing.py` detects the `@` symbol in the URL and delegates to `fetch_artist_songs` in `utils/artist_song_utils.py`.
  - __Song URL Extraction:__ Using Pyppeteer, `fetch_artist_songs` loads the artist page, executes JavaScript to find all `<a>` tags with `href` attributes starting with `/song/`, and constructs full URLs (e.g., `https://suno.com/song/{songId}`). This captures all songs listed on the page, handling pagination implicitly if Suno loads all songs dynamically.
  - __Song Data Fetching:__ For each song URL, `fetch_song_data` in `suno/fetch.py` retrieves detailed metadata (title, artist, audio URL, upload date, album art URL) by scraping the page.

- __Downloading Songs:__
  - __Execution:__ Back in `process_urls`, each song's data is passed to `download_song` in `utils/file_utils.py`.
  - __File Saving:__ It downloads the MP3 from the `audio_url` and the cover art from the `album_art_url`, saving them to `./downloads/{artist}/{title}.mp3` and `./downloads/{artist}/{title}.jpeg`, respectively.
  - __Metadata Embedding:__ Using Mutagen, it embeds metadata (title, artist, upload date) and the cover art into the MP3 file.
  - __Logging:__ Success or failure is logged in `song_data.txt` via `log_song_data`.

- __Relevance to Song Library:__ This approach directly extracts all songs from a user's artist page, making it the most straightforward method for accessing a full song library without requiring a playlist. However, it assumes the artist page lists all songs, which depends on Suno's interface (e.g., no hidden pagination limits).

---

#### __Comparison And Applicability__

- __Suno Music Downloader:__
  - __Strength:__ User-friendly GUI, efficient for playlists, embeds cover art into MP3s.
  - __Limitation:__ Requires a playlist URL; doesn't natively handle artist pages or the full library unless all songs are in a playlist.
  - __Use Case:__ Best if the user has organized their library into a playlist.

- __Sunodl:__
  - __Strength:__ Can extract songs from artist pages (likely the full library), handles multiple URL types (songs, playlists, artist pages), command-line flexibility.
  - __Limitation:__ Requires Python setup, less intuitive for non-technical users, assumes all songs are visible on the artist page.
  - __Use Case:__ Ideal for directly accessing a user's entire library via their artist page URL.

---

#### __Conclusion__

Yes, the provided tools can extract all songs from a Suno.com user's song library:

- __Via Playlists:__ The Suno Music Downloader (`Sunodownloader/`) fetches and downloads all songs from a playlist URL, suitable if the user's library is represented as a playlist.
- __Via Artist Pages:__ The Sunodl Python scripts (`Sunodl/`) extract and download all songs from a user's artist page, offering a direct method to access the full library.

For a complete solution, __Sunodl__ is more directly applicable since artist pages typically list all user-created songs, while the Tauri app requires a playlist intermediary. Both tools successfully download the songs once extracted, with Sunodl providing broader URL compatibility and the Tauri app offering a polished desktop experience.

---

### What is Suno?

Suno is an AI-powered tool for generating music. You can:

- Input custom lyrics or let it generate them.
- Define musical styles (e.g., "Epic Orchestral," "Indie Rock").
- Upload your own audio (like instrumentals or vocals) for it to build upon.
- Choose between versions: v3.5 excels in song structure and instrumentals, while v4 improves vocal quality.

---

### Best Tips and Tricks for Using Suno

#### 1. Prompt Structuring

Crafting effective prompts is key to controlling Suno’s output:

- __Punctuation Matters__: Use commas (,) for short pauses, ellipses (…) for longer pauses, and quotation marks ("") to shift voice styles or accents (e.g., "Southern drawl"). Capitalize words (e.g., LOVE) for emphasis.
- __Unique Accents__: Add non-standard characters (e.g., ø for "uh," რ for rolled "r") in lyrics, then remaster with standard text to get creative vocal styles.
- __Detailed Style Prompts__: In the "Style of Music" field (max 200 characters), include genre, instruments, atmosphere, and specifics like BPM or vocal type. Example: "Epic Orchestral, war drums, male choir, heroic, 78 BPM, contralto voice."

#### 2. Song Structure

A clear structure helps Suno deliver cohesive songs:

- __Standard Layout__: Use tags like `[Intro]`, `[Verse]`, `[Chorus]`, `[Bridge]`, `[Outro]` to organize sections. Add `[Instrumental]` or `[Guitar Solo]` for variety.
- __Meta-Tags__: Enhance control with tags like `[Dynamic: ff]` (loud), `[Tempo: 80 BPM]`, or `[Instructions: Build intensity]`. Example: `[Chorus, Full Orchestra, Choir, ff, Build intensity]`.
- __Instrumentals First__: Generate an instrumental base, then extend with lyrics for better vocal integration.

#### 3. Vocal Control

Fine-tune vocals for your vision:

- __Specify Voices__: Use `[Male Vocal]`, `[Female Vocal]`, or `[Duet]` before sections. For duets, assign lines like `[Male] Line 1`, `[Female] Line 2`.
- __Call and Response__: Tag `[Call and Response]` or alternate voices for dynamic interplay. Regenerate if voices misalign.
- __Unique Effects__: Try `[Whisper]`, `[Melismatic]` (runs across scales), or `[Kulning]` (high-pitched calls) for expressive vocals.

#### 4. Avoiding Common Issues

Suno v4 has quirks—here’s how to fix them:

- __Buried Vocals__: Boost 2kHz–5kHz, cut 200Hz–500Hz in instruments post-download.
- __Harsh Highs__: Reduce 8kHz–12kHz to tame cymbals or sibilance ("S" sounds).
- __Muddy Mix__: Cut 200Hz–400Hz for clarity.
- __Abrupt Endings__: Add `[Fade Out]` or manually fade in an editor.

#### 5. Creative Techniques

Push Suno’s boundaries with these hacks:

- __Onomatopoeia__: Use `[Sitar, shimmering note, eeeeeennnnnn]` for complex effects.
- __Genre Blending__: Mix styles like "Hindi Boombap" or "Japanese Reggae" for unique results.
- __External Tools__: Use ChatGPT to craft lyrics or structures, then refine in Suno. Example: Ask for a "tribal epic" structure, then tag it with `[Taiko Drums, Choir]`.

#### 6. Post-Processing

Polish your tracks after generation:

- __Download WAV__: Always opt for WAV over MP3 for higher quality.
- __EQ Fixes__: Cut muddiness (200Hz–400Hz), tame highs (8kHz–12kHz), boost presence (2kHz–5kHz).
- __Stereo Adjustments__: Convert to mono to fix extreme panning, then widen subtly with tools like BandLab or Audacity.

#### 7. Miscellaneous Tips

- __Double Brackets__: Use `[[]]` for tags (e.g., `[[Chop, Echo]]`) to avoid Suno singing them as lyrics.
- __Randomness__: Add QRNG strings (e.g., from qrng.anu.edu.au) to prompts for variety.
- __Monetization Hack__: For free-version songs, extend by a few seconds and regenerate to potentially bypass restrictions (check Suno’s terms).

---

### Examples from Users

- __Epic Music__: `[Chorus, Thunderous Choir, Taiko Drums, ff]` with lyrics like “Odin guides us!” creates a cinematic climax ([Epoyato](https://suno.com/song/0d77cdd9-d49c-44eb-9ac2-c3c6a910e910)).
- __Duet__: `[Male] I sing this… [Female] I reply…` for alternating voices ([CharmingAd2038](https://open.spotify.com/track/2Ompx6uQfyGKYtIIm5Lgz0)).
- __Instrumental__: Use symbolic patterns (e.g., `|-| … |_|`) instead of lyrics with `[Indie Rock, Fingerpicking]` ([Tr0ubledove](https://suno.com/song/5ce6900e-51a1-4072-b370-b8e9d54fcd41)).

---

### Final Advice

Suno shines when you experiment. Start simple—try `[Intro, Soft Piano]`, `[Chorus, Female Vocal, ff]`—then layer complexity. Regenerate often (5–20 times) to refine results, and don’t shy away from post-editing for polish. Whether you’re crafting a tribal anthem or a chill instrumental, these tips will elevate your Suno creations!

================================================
File: download_cover_art.js
================================================

import * as fs from 'fs/promises';
import { parse } from 'node-html-parser';
import path from 'path';

const BASE_PATH = 'C:\\Users\\User\\Documents\\Github\\suno_ai_downloader\\cover_art';

async function main() {
  const filePath = 'C://Users//User//Documents//Github//suno_ai_downloader//unique_songs.txt'; // Path to your URL list

  try {
    const fileContent = await fs.readFile(filePath, 'utf-8');
    const urls = fileContent.split(/\s+/).filter(line => line.trim() !== '');

    for (const url of urls) {
      const uuid = url.match(
        /\b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b/,
      );

      if (!uuid) {
        console.error('Invalid UUID:', url);
        continue;
      }

      console.log('Processing UUID:', uuid[0]);
      const formattedUrl = `https://suno.com/song/${uuid[0]}`;

      try {
        await fetchAndSaveCoverArt(formattedUrl); //  Call the function to fetch and save
      } catch (err) {
        console.error(`Error processing ${formattedUrl}:`, err);
      }
    }
  } catch (err) {
    console.error('Error reading file:', err);
  }
}

async function fetchAndSaveCoverArt(url) {
  const result = await fetch(url);
  if (!result.ok) {
    console.error('Failed to fetch:', url);
    return;
  }
  const html = await result.text();
  const root = parse(html);

  let pushedData = '';

  // Loop over all script tags, same logic as your original script
  for (const script of root.querySelectorAll('script')) {
    if (!script.text.startsWith('self.__next_f.push([')) {
      continue;
    }

    const data = script.text.match(
      /\s*self\.__next_f.push\(\[\s*1,\s*"(?<wanted>.*)",?\s*\]\);?/m,
    );
    if (data && data[1]) {
      const better = JSON.parse(`"${data[1]}"`);
      pushedData += better;
    }
  }

  const start = pushedData.indexOf('{"clip":');
  if (start === -1) {
    console.error('Failed to find clip data in', url);
    return;
  }

  const clip = pushedData.slice(start);
  let json = null;
  let endCut = 0;

  try {
    json = JSON.parse(clip);
  } catch (e) {
    const position = e.message.match(/position (\d+)/);
    if (position) {
      endCut = parseInt(position[1]);
    } else {
      console.error('Failed to parse json:', e);
      return;
    }

    try {
      json = JSON.parse(clip.slice(0, endCut));
    } catch (e) {
      console.error('Failed to parse json again:', e);
      return;
    }
  }
    if(!json || !json.clip) {
        console.error('Failed to parse clip data:', url);
        return;
    }

  await doImage(json.clip); // Call doImage with the clip data
}

async function doImage(data) {
  const artBuffer = await fetch(data.image_large_url).then((res) =>
    res.arrayBuffer(),
  );

  // Get the song title
  const songTitle = data.title;

  // Create the song directory
  const songDirPath = path.join(BASE_PATH, songTitle);
  await fs.mkdir(songDirPath, { recursive: true });

  // Define the base filename (only the song title)
  let baseFilename = songTitle;
  let filename = path.join(songDirPath, `${baseFilename}.jpg`);

  // Check if file exists, and use Roman numerals for duplicates
  filename = await getUniqueFilenameRoman(filename, songDirPath, baseFilename);

  // Save the image file
  await fs.writeFile(filename, Buffer.from(artBuffer));
  console.log('Wrote cover art:', filename);
}

// Function to get a unique filename using Roman numerals
async function getUniqueFilenameRoman(filepath, dir, baseFilename) {
    let ext = path.extname(filepath);
    let filename = path.basename(filepath, ext);
    let counter = 0; // Start at 0, first instance will be without Roman Numeral
    let newFilename = path.join(dir, `${baseFilename}${ext}`);

    while (await fileExists(newFilename)) {
        counter++;
        const roman = toRoman(counter);
        newFilename = path.join(dir, `${baseFilename} ${roman}${ext}`);
    }

    return newFilename;
}

// Helper function to convert numbers to Roman numerals
function toRoman(num) {
  const romanMap = {
    1: 'I',
    4: 'IV',
    5: 'V',
    9: 'IX',
    10: 'X',
    40: 'XL',
    50: 'L',
    90: 'XC',
    100: 'C',
    400: 'CD',
    500: 'D',
    900: 'CM',
    1000: 'M',
  };

  let result = '';
  const decimalValues = Object.keys(romanMap).map(Number).sort((a, b) => b - a);

  for (const decimal of decimalValues) {
    while (num >= decimal) {
      result += romanMap[decimal];
      num -= decimal;
    }
  }

  return result;
}

// Helper function to check if a file exists
async function fileExists(filepath) {
  try {
    await fs.access(filepath);
    return true;
  } catch (err) {
    return false;
  }
}

main();

================================================
File: extrctr.js
================================================

import * as cheerio from 'cheerio';
import axios from 'axios';

async function extractSunoData(url) {
    try {
        const response = await axios.get(url);
        const html = response.data;
        const $ = cheerio.load(html);
        let sunoData = null;

        // Extract SUNO_DATA
        $('script').each((i, script) => {
            const scriptContent = $(script).html();
            if (scriptContent && scriptContent.includes('window.__SUNO_DATA__')) {
                const regex = /window\.__SUNO_DATA__\s*=\s*({.*?});/s;
                const match = regex.exec(scriptContent);
                if (match && match[1]) {
                    try {
                        sunoData = JSON.parse(match[1]);

                        // Stop iterating once data is found
                        return false; // This is how you break out of a cheerio each loop


                    } catch (e) {
                        console.error("Error parsing SUNO_DATA:", e);
                        return false; // Stop in case of parse error
                    }
                }
            }
        });



        if (sunoData) {
            return { jsonData: sunoData }; // Return only the relevant data
        } else {
            return { error: "Could not find window.__SUNO_DATA__" }; // Specific error
        }

    } catch (error) {
        console.error("Error fetching or processing URL:", error);
        return { error: error.message }; // Detailed error message
    }
}

async function main() {
    const sunoUrl = process.argv[2];

    if (!sunoUrl) {
        console.error("Please provide a Suno URL as a command-line argument.");
        return;
    }

    const extractedData = await extractSunoData(sunoUrl);
    console.log(JSON.stringify(extractedData, null, 2)); // Pretty-print JSON

}

main();

================================================
File: ids.py
================================================

import re

def extract_ids(input_file, output_file):
    id_pattern = re.compile(r'"id":\s*"([^"]+)"')
    ids = []

    with open(input_file, 'r') as infile:
        for line in infile:
            match = id_pattern.search(line)
            if match:
                ids.append(match.group(1))

    with open(output_file, 'w') as outfile:
        for id in ids:
            outfile.write(id + '\n')

if __name__ == "__main__":
    input_file = "SunoAI2.txt"
    output_file = "extracted_ids.txt"
    extract_ids(input_file, output_file)
    print(f"IDs have been extracted to {output_file}")

================================================
File: index.js
================================================

import * as fs from 'fs/promises';
import MP3Tag from 'mp3tag.js';
import { parse } from 'node-html-parser';
import path from 'path';

const BASE_PATH = 'C:\\Users\\User\\Documents\\Github\\suno_ai_downloader\\tracks';

async function main() {
  const filePath = 'C://Users//User//Documents//Github//suno_ai_downloader//unique_songs.txt';

  try {
    const fileContent = await fs.readFile(filePath, 'utf-8');
    const urls = fileContent.split(/\s+/).filter(line => line.trim() !== '');

    for (const url of urls) {
      const uuid = url.match(
        /\b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b/,
      );

      if (!uuid) {
        console.error('Invalid UUID:', url);
        continue;
      }

      console.log('Processing UUID:', uuid[0]);
      const formattedUrl = `https://suno.com/song/${uuid[0]}`;

      try {
        // Pass the UUID (song ID) along with the URL
        await fetchSongData(formattedUrl, uuid[0]);
      } catch (err) {
        console.error(`Error processing ${formattedUrl}:`, err);
      }
    }
  } catch (err) {
    console.error('Error reading file:', err);
  }
}

// Note: Added a second parameter "songId" to receive the song UUID
async function fetchSongData(url, songId) {
  const result = await fetch(url);
  if (!result.ok) {
    console.error('Failed to fetch:', url);
    return;
  }
  const html = await result.text();
  const root = parse(html);

  let pushedData = '';

  // Loop over all script tags to find the one with the pushed data
  for (const script of root.querySelectorAll('script')) {
    // Check if script tag contains desired data
    if (!script.text.startsWith('self.__next_f.push([')) {
      continue;
    }

    // Extract the data from the script tag using regex
    const data = script.text.match(
      /\s*self\.__next_f.push\(\[\s*1,\s*"(?<wanted>.*)",?\s*\]\);?/m,
    );
    if (data && data[1]) {
      const better = JSON.parse(`"${data[1]}"`);
      pushedData += better;
    }
  }

  // Extract JSON data starting from '{"clip":'
  const start = pushedData.indexOf('{"clip":');
  if (start === -1) {
    console.error('Failed to find clip data in', url);
    return;
  }

  const clip = pushedData.slice(start);
  let json = null;
  let endCut = 0;

  try {
    json = JSON.parse(clip);
  } catch (e) {
    const position = e.message.match(/position (\d+)/);
    if (position) {
      endCut = parseInt(position[1]);
    } else {
      console.error('Failed to parse json:', e);
      return;
    }

    try {
      json = JSON.parse(clip.slice(0, endCut));
    } catch (e) {
      console.error('Failed to parse json again:', e);
      return;
    }
  }

  // Pass the songId down to doSong
  await doSong(json.clip, songId);
}

// Updated doSong function to accept the songId parameter
async function doSong(data, songId) {
  const mp3Buffer = await fetch(data.audio_url).then((res) =>
    res.arrayBuffer(),
  );
  const artBuffer = await fetch(data.image_large_url).then((res) =>
    res.arrayBuffer(),
  );

  const songTitle = data.title;
  const songDirPath = path.join(BASE_PATH, songTitle);
  await fs.mkdir(songDirPath, { recursive: true });

  // Define the base filename (only the song title)
  let baseFilename = songTitle;
  let filename = path.join(songDirPath, `${baseFilename}.mp3`);

  // Check if file exists, and use Roman numerals for duplicates
  filename = await getUniqueFilenameRoman(filename, songDirPath, baseFilename);

  // Apply metadata to MP3 using MP3Tag.js
  const tag = new MP3Tag(Buffer.from(mp3Buffer));
  tag.read();
  tag.tags.title = songTitle;          // Use only song title
  tag.tags.artist = data.display_name;
  tag.tags.album = songTitle;          // Set album tag
  tag.tags.genre = data.metadata.tags;
  // Here we incorporate the song ID into the comment tag for later duplicate filtering.
  tag.tags.comment = `Suno AI (Song ID: ${songId})`;
  tag.tags.year = new Date(data.created_at).getFullYear().toString();
  tag.tags.v2.APIC = [
    {
      format: 'image/jpeg',
      type: 0,
      description: 'Suno AI',
      data: Buffer.from(artBuffer),
    },
  ];

  // Alternatively, if you prefer to store the song ID in a custom tag (e.g., TXXX),
  // you could uncomment the following block (provided MP3Tag.js supports it):
  /*
  tag.tags.v2.TXXX = [
    {
      description: 'Song ID',
      data: songId,
    },
  ];
  */

  // Save the MP3 file
  await fs.writeFile(
    filename,
    Buffer.from(
      tag.save({
        strict: true, // Strict mode, validates all inputs against the standards.
        id3v2: { padding: 4096 },
      }),
    ),
  );

  if (tag.error) {
    console.error('MP3Tag error:', tag.error);
  } else {
    console.log('Wrote:', filename);
  }
}

// Function to get a unique filename using Roman numerals
async function getUniqueFilenameRoman(filepath, dir, baseFilename) {
  let ext = path.extname(filepath);
  let filename = path.basename(filepath, ext);
  let counter = 0; // Start at 0, first instance will be without Roman Numeral
  let newFilename = path.join(dir, `${baseFilename}${ext}`);

  while (await fileExists(newFilename)) {
    counter++;
    const roman = toRoman(counter);
    newFilename = path.join(dir, `${baseFilename} ${roman}${ext}`);
  }

  return newFilename;
}

// Helper function to convert numbers to Roman numerals
function toRoman(num) {
  const romanMap = {
    1: 'I',
    4: 'IV',
    5: 'V',
    9: 'IX',
    10: 'X',
    40: 'XL',
    50: 'L',
    90: 'XC',
    100: 'C',
    400: 'CD',
    500: 'D',
    900: 'CM',
    1000: 'M',
  };

  let result = '';
  const decimalValues = Object.keys(romanMap)
    .map(Number)
    .sort((a, b) => b - a);

  for (const decimal of decimalValues) {
    while (num >= decimal) {
      result += romanMap[decimal];
      num -= decimal;
    }
  }

  return result;
}

// Helper function to check if a file exists
async function fileExists(filepath) {
  try {
    await fs.access(filepath);
    return true;
  } catch (err) {
    return false;
  }
}

main();

================================================
File: info.js
================================================

import * as fs from 'fs/promises';
import fetch from 'node-fetch';
import { parse } from 'node-html-parser';
// Removed 'path' import since it's not used

async function fetchPageContent(url) {
    const response = await fetch(url);
    if (!response.ok) {
        throw new Error(`Failed to fetch page: ${response.statusText}`);
    }
    const html = await response.text();
    return html;
}

function extractScriptTags(html) {
    const root = parse(html);
    const scriptTags = root.querySelectorAll('script');
    return scriptTags;
}

function findDataScripts(scriptTags) {
    return scriptTags.filter(script => script.text.includes('self.__next_f.push'));
}

function extractDataFromScripts(dataScripts) {
    let concatenatedData = '';
    let lyricsData = '';

    for (const script of dataScripts) {
        const match = script.text.match(/self\.__next_f\.push\(\[\d+,"(.*)"\]\)/s);
        if (match && match[1]) {
            // Unescape the string
            const unescapedString = JSON.parse(`"${match[1]}"`);
            // Check if the string contains JSON data
            if (unescapedString.trim().startsWith('{"clip":')) {
                concatenatedData += unescapedString;
            } else {
                // Collect lyrics or other text content
                lyricsData += unescapedString + '\n';
            }
        }
    }

    return { concatenatedData, lyricsData };
}

function extractJsonData(concatenatedData) {
    const jsonStartIndex = concatenatedData.indexOf('{"clip":');
    if (jsonStartIndex === -1) {
        throw new Error('JSON data not found in concatenated string.');
    }

    const jsonString = concatenatedData.slice(jsonStartIndex);

    let jsonData;
    try {
        jsonData = JSON.parse(jsonString);
    } catch (error) {
        const positionMatch = error.message.match(/at position (\d+)/);
        if (positionMatch) {
            const validJsonSubstring = jsonString.slice(0, parseInt(positionMatch[1]));
            jsonData = JSON.parse(validJsonSubstring);
        } else {
            throw new Error('Failed to parse JSON data.');
        }
    }

    return jsonData;
}

function extractSongInformation(jsonData) {
    const clip = jsonData.clip;

    const title = clip.title || 'Unknown Title';
    const artist = clip.display_name || 'Unknown Artist';
    const coverImageUrl = clip.image_large_url || clip.image_url || 'No Image URL';
    const creationDate = clip.created_at || 'Unknown Date';
    const audioUrl = clip.audio_url || 'No Audio URL';
    const tags = clip.metadata.tags || 'No Tags';

    return {
        title,
        artist,
        coverImageUrl,
        creationDate,
        audioUrl,
        tags,
    };
}

function sanitizeFileName(name) {
    return name.replace(/[<>:"/\\|?*]/g, '-');
}

async function saveSongDetailsAsMarkdown(details) {
    const {
        title,
        artist,
        tags,
        lyrics,
        coverImageUrl,
        creationDate,
        audioUrl,
    } = details;

    const markdownContent = `

# ${title}

![Cover Image](${coverImageUrl})

__Artist:__ ${artist}
**Tags:** ${tags}
__Release Date:__ ${creationDate}
**Listen:** [MP3 Link](${audioUrl})

## Lyrics

${lyrics}
`;

    const sanitizedArtist = sanitizeFileName(artist);
    const sanitizedTitle = sanitizeFileName(title);
    const markdownFilename = `songs/${sanitizedArtist} - ${sanitizedTitle}.md`;

    await fs.writeFile(markdownFilename, markdownContent);
    console.log(`Saved markdown: ${markdownFilename}`);
}

// Only one definition of processURL
async function processURL(url) {
    try {
        const html = await fetchPageContent(url);
        const scriptTags = extractScriptTags(html);
        const dataScripts = findDataScripts(scriptTags);
        const { concatenatedData, lyricsData } = extractDataFromScripts(dataScripts);
        const jsonData = extractJsonData(concatenatedData);
        const songDetails = extractSongInformation(jsonData);
        songDetails.lyrics = lyricsData.trim() || 'Lyrics not available';

        // Save the song details as markdown
        await saveSongDetailsAsMarkdown(songDetails);
    } catch (error) {
        console.error(`An unexpected error occurred while processing ${url}:`, error);
    }
}

// Get the URL from the command line arguments
const args = process.argv.slice(2);
if (args.length === 0) {
    console.error('Please provide a Suno URL as an argument');
    process.exit(1);
}

const songUrl = args[0];
processURL(songUrl);

================================================
File: json2md.py
================================================

import json
import os

def create_markdown_from_suno_json(json_file):
    """Parses a Suno JSON file and creates a formatted Markdown file."""

    with open(json_file, "r") as f:
        data = json.load(f)

    markdown_file = os.path.splitext(json_file)[0] + ".md"

    with open(markdown_file, "w", encoding="utf-8") as f:
        for song in data:
            f.write(f"# Title: {song['title']}\n\n")
            f.write(f"Image URL: {song['image_url']}\n\n")

            f.write(f"**Created At:** {song['created_at']}\n")
            f.write(f"**Song ID:** {song['id']}\n")
            f.write(f"**Duration:** {song['duration']}\n\n")

            f.write(f"**Audio URL:** {song['audio_url']}\n")
            f.write(f"**Video URL:** {song['video_url']}\n\n")

            f.write(f"**Tags:** {song['tags']}\n\n")

            f.write(f"**Lyrics:**\n\n")
            f.write(f"```\n{format_lyrics(song['lyric'])}\n```\n\n")

            f.write(f"---\n\n")  # Separator between songs

def format_lyrics(lyrics):
    """Formats lyrics by adding extra newlines after section headers."""
    formatted_lyrics = ""
    for line in lyrics.splitlines():
        if line.startswith("["):  # Add an extra newline *before* section headers
            formatted_lyrics += "\n"
        formatted_lyrics += line + "\n"
    return formatted_lyrics

if __name__ == "__main__":
    json_filename = "suno.json"
    create_markdown_from_suno_json(json_filename)
    print(f"Markdown file '{json_filename}.md' created successfully.")

================================================
File: json_analyzer.py
================================================

import json
import jsonschema
from jsonschema import validate

def read_large_json(file_path, chunk_size=1024):
    with open(file_path, 'r') as file:
        buffer = ""
        while True:
            chunk = file.read(chunk_size)
            if not chunk:
                break
            buffer += chunk
            while True:
                try:
                    obj, idx = json.JSONDecoder().raw_decode(buffer)
                    yield obj
                    buffer = buffer[idx:].lstrip()
                except json.JSONDecodeError:
                    break

def validate_json(json_data, schema):
    try:
        validate(instance=json_data, schema=schema)
    except jsonschema.exceptions.ValidationError as err:
        return str(err)
    return None

def analyze_json(file_path, schema=None):
    errors = []
    for json_obj in read_large_json(file_path):
        if schema:
            error = validate_json(json_obj, schema)
            if error:
                errors.append(error)
    return errors

if __name__ == "__main__":
    file_path = r"C:\Users\whois\Documents\suno_ai_downloader\suno.json"  # Use raw string
    schema = {
        # Define your JSON schema here if you have one
    }
    errors = analyze_json(file_path, schema)
    if errors:
        print("Errors found in JSON file:")
        for error in errors:
            print(error)
    else:
        print("No errors found in JSON file.")

================================================
File: main.py
================================================

import os
import requests
from bs4 import BeautifulSoup

def get_song_title(html):
    try:
        soup = BeautifulSoup(html, 'html.parser')
        heading_tag = soup.select_one('.chakra-heading')
        if heading_tag:
            song_title = heading_tag.text.strip()
            return song_title
        else:
            print("No song title found.")
            return None
    except Exception as e:
        print(f"Error while parsing HTML: {e}")
        return None

def download_song_from_page(song_page_url, save_dir="music"):
    try:
        if not song_page_url.startswith("<https://suno.com/song/>"):
            raise ValueError(
                "Incorrect URL. It should start with '<https://suno.com/song/>'")

        song_id = song_page_url.split('/')[-1]
        song_page_title = f"https://suno.com/embed/{song_id}"
        response_title = requests.get(song_page_title)
        if response_title.status_code != 200:
            print(f"Error: {response.status_code}")
            return

        html = response_title.text
        song_title = get_song_title(html)
        if not song_title:
            return

        song_url = f"https://cdn1.suno.ai/{song_id}.mp3"

        file_name = f"{song_title}.mp3"
        file_path = os.path.join(save_dir, file_name)

        if not os.path.exists(save_dir):
            os.makedirs(save_dir)

        response = requests.get(song_url, stream=True)
        if response.status_code == 200:
            with open(file_path, 'wb') as file:
                for chunk in response.iter_content(chunk_size=1024):
                    file.write(chunk)
            print(f"{file_name} downloaded in {file_path}")
        else:
            print(f"Download error {file_name}: {response.status_code}")
    except ValueError as ve:
        print(ve)
    except Exception as e:
        print(f"There's been an error: {e}")

if __name__ == "__main__":
    print("Software for downloading music from suno.com")
    print("Go to suno.com, pick a song you like, go to the song page and copy the link.")
    print("Example link: <https://suno.com/song/eaba4d6e-f7ab-4bc4-a48b-6e2c8d859dbc>")
    print("Paste the link at the bottom and press Enter.")
    while True:
        song_page_url = input(f"\nEnter a link to the song's page: ")
        download_song_from_page(song_page_url)
        if (input("Would you like to continue? (y/n): ") == "n"):
            break

================================================
File: suno api.md
================================================

# suno api

---

<div align="center">
  <h1 align="center"">
      Suno AI API
  </h1>
  <p>Use API to call the music generation AI of Suno.ai and easily integrate it into agents like GPTs.</p>
  <p>👉 We update quickly, please star.</p>
</div>
<p align="center">
  <a target="_blank" href="./README.md">English</a>
  | <a target="_blank" href="./README_CN.md">简体中文</a>
  | <a target="_blank" href="https://suno.gcui.ai">Demo</a>
  | <a target="_blank" href="https://suno.gcui.ai/docs">Docs</a>
  | <a target="_blank" href="https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fgcui-art%2Fsuno-api&env=SUNO_COOKIE&project-name=suno-api&repository-name=suno-api">Deploy with Vercel</a>
</p>
<p align="center">
  <a href="https://www.producthunt.com/products/gcui-art-suno-api-open-source-sunoai-api/reviews?utm_source=badge-product_review&utm_medium=badge&utm_souce=badge-gcui&#0045;art&#0045;suno&#0045;api&#0045;open&#0045;source&#0045;sunoai&#0045;api" target="_blank"><img src="https://api.producthunt.com/widgets/embed-image/v1/product_review.svg?product_id=577408&theme=light" alt="gcui&#0045;art&#0047;suno&#0045;api&#0058;Open&#0045;source&#0032;SunoAI&#0032;API - Use&#0032;API&#0032;to&#0032;call&#0032;the&#0032;music&#0032;generation&#0032;AI&#0032;of&#0032;suno&#0046;ai&#0046; | Product Hunt" style="width: 250px; height: 54px;" width="250" height="54" /></a>
</p>

> 🔥 Check out our new open-source project: [Album AI - Chat with your gallery using plain language!](https://github.com/gcui-art/album-ai)

![suno-api banner](https://github.com/gcui-art/suno-api/blob/main/public/suno-banner.png)

## Introduction

Suno.ai v3 is an amazing AI music service. Although the official API is not yet available, we couldn't wait to integrate its capabilities somewhere.

We discovered that some users have similar needs, so we decided to open-source this project, hoping you'll like it.

## Demo

We have deployed an example bound to a free Suno account, so it has daily usage limits, but you can see how it runs:
[suno.gcui.ai](https://suno.gcui.ai)

## Features

- Perfectly implements the creation API from app.suno.ai
- Automatically keep the account active.
- Compatible with the format of OpenAI’s `/v1/chat/completions` API.
- Supports Custom Mode
- One-click deployment to Vercel
- In addition to the standard API, it also adapts to the API Schema of Agent platforms like GPTs and Coze, so you can use it as a tool/plugin/Action for LLMs and integrate it into any AI Agent.
- Permissive open-source license, allowing you to freely integrate and modify.

## Getting Started

### 1. Obtain the cookie of your app.suno.ai account

1. Head over to [app.suno.ai](https://app.suno.ai) using your browser.
2. Open up the browser console: hit `F12` or access the `Developer Tools`.
3. Navigate to the `Network tab`.
4. Give the page a quick refresh.
5. Identify the request that includes the keyword `client?_clerk_js_version`.
6. Click on it and switch over to the `Header` tab.
7. Locate the `Cookie` section, hover your mouse over it, and copy the value of the Cookie.

![get cookie](https://github.com/gcui-art/suno-api/blob/main/public/get-cookie-demo.gif)

### 2. Clone and deploy this project

You can choose your preferred deployment method:

#### Deploy to Vercel

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fgcui-art%2Fsuno-api&env=SUNO_COOKIE&project-name=suno-api&repository-name=suno-api)

#### Run locally

```bash
git clone https://github.com/gcui-art/suno-api.git
cd suno-api
npm install
```

Alternatively, you can use [Docker Compose](https://docs.docker.com/compose/)

```bash
docker compose build && docker compose up
```

### 3. Configure suno-api

- If deployed to Vercel, please add an environment variable `SUNO_COOKIE` in the Vercel dashboard, with the value of the cookie obtained in the first step.

- If you’re running this locally, be sure to add the following to your `.env` file:

```bash
SUNO_COOKIE=<your-cookie>
```

### 4. Run suno api

- If you’ve deployed to Vercel:
  - Please click on Deploy in the Vercel dashboard and wait for the deployment to be successful.
  - Visit the `https://<vercel-assigned-domain>/api/get_limit` API for testing.
- If running locally:
  - Run `npm run dev`.
  - Visit the `http://localhost:3000/api/get_limit` API for testing.
- If the following result is returned:

```json
{
  "credits_left": 50,
  "period": "day",
  "monthly_limit": 50,
  "monthly_usage": 50
}
```

it means the program is running normally.

### 5. Use Suno API

You can check out the detailed API documentation at :
[suno.gcui.ai/docs](https://suno.gcui.ai/docs)

## API Reference

Suno API currently mainly implements the following APIs:

```bash
- `/api/generate`: Generate music
- `/v1/chat/completions`: Generate music - Call the generate API in a format that works with OpenAI’s API.
- `/api/custom_generate`: Generate music (Custom Mode, support setting lyrics, music style, title, etc.)
- `/api/generate_lyrics`: Generate lyrics based on prompt
- `/api/get`: Get music information based on the id. Use “,” to separate multiple ids.
    If no IDs are provided, all music will be returned.
- `/api/get_limit`: Get quota Info
- `/api/extend_audio`: Extend audio length
- `/api/clip`: Get clip information based on ID passed as query parameter `id`
- `/api/concat`: Generate the whole song from extensions
```

For more detailed documentation, please check out the demo site:
[suno.gcui.ai/docs](https://suno.gcui.ai/docs)

## API Integration Code Example

### Python

```python
import time
import requests

# replace your vercel domain
base_url = 'http://localhost:3000'


def custom_generate_audio(payload):
    url = f"{base_url}/api/custom_generate"
    response = requests.post(url, json=payload, headers={'Content-Type': 'application/json'})
    return response.json()


def extend_audio(payload):
    url = f"{base_url}/api/extend_audio"
    response = requests.post(url, json=payload, headers={'Content-Type': 'application/json'})
    return response.json()

def generate_audio_by_prompt(payload):
    url = f"{base_url}/api/generate"
    response = requests.post(url, json=payload, headers={'Content-Type': 'application/json'})
    return response.json()


def get_audio_information(audio_ids):
    url = f"{base_url}/api/get?ids={audio_ids}"
    response = requests.get(url)
    return response.json()


def get_quota_information():
    url = f"{base_url}/api/get_limit"
    response = requests.get(url)
    return response.json()

def get_clip(clip_id):
    url = f"{base_url}/api/clip?id={clip_id}"
    response = requests.get(url)
    return response.json()

def generate_whole_song(clip_id):
    payloyd = {"clip_id": clip_id}
    url = f"{base_url}/api/concat"
    response = requests.post(url, json=payload)
    return response.json()


if __name__ == '__main__':
    data = generate_audio_by_prompt({
        "prompt": "A popular heavy metal song about war, sung by a deep-voiced male singer, slowly and melodiously. The lyrics depict the sorrow of people after the war.",
        "make_instrumental": False,
        "wait_audio": False
    })

    ids = f"{data[0]['id']},{data[1]['id']}"
    print(f"ids: {ids}")

    for _ in range(60):
        data = get_audio_information(ids)
        if data[0]["status"] == 'streaming':
            print(f"{data[0]['id']} ==> {data[0]['audio_url']}")
            print(f"{data[1]['id']} ==> {data[1]['audio_url']}")
            break
        # sleep 5s
        time.sleep(5)

```

### Js

```js
const axios = require("axios");

// replace your vercel domain
const baseUrl = "http://localhost:3000";

async function customGenerateAudio(payload) {
  const url = `${baseUrl}/api/custom_generate`;
  const response = await axios.post(url, payload, {
    headers: { "Content-Type": "application/json" },
  });
  return response.data;
}

async function generateAudioByPrompt(payload) {
  const url = `${baseUrl}/api/generate`;
  const response = await axios.post(url, payload, {
    headers: { "Content-Type": "application/json" },
  });
  return response.data;
}

async function extendAudio(payload) {
  const url = `${baseUrl}/api/extend_audio`;
  const response = await axios.post(url, payload, {
    headers: { "Content-Type": "application/json" },
  });
  return response.data;
}

async function getAudioInformation(audioIds) {
  const url = `${baseUrl}/api/get?ids=${audioIds}`;
  const response = await axios.get(url);
  return response.data;
}

async function getQuotaInformation() {
  const url = `${baseUrl}/api/get_limit`;
  const response = await axios.get(url);
  return response.data;
}

async function getClipInformation(clipId) {
  const url = `${baseUrl}/api/clip?id=${clipId}`;
  const response = await axios.get(url);
  return response.data;
}

async function main() {
  const data = await generateAudioByPrompt({
    prompt:
      "A popular heavy metal song about war, sung by a deep-voiced male singer, slowly and melodiously. The lyrics depict the sorrow of people after the war.",
    make_instrumental: false,
    wait_audio: false,
  });

  const ids = `${data[0].id},${data[1].id}`;
  console.log(`ids: ${ids}`);

  for (let i = 0; i < 60; i++) {
    const data = await getAudioInformation(ids);
    if (data[0].status === "streaming") {
      console.log(`${data[0].id} ==> ${data[0].audio_url}`);
      console.log(`${data[1].id} ==> ${data[1].audio_url}`);
      break;
    }
    // sleep 5s
    await new Promise((resolve) => setTimeout(resolve, 5000));
  }
}

main();
```

## Integration with Custom Agents

You can integrate Suno AI as a tool/plugin/action into your AI agent.

### Integration with GPTs

[coming soon...]

### Integration with Coze

[coming soon...]

### Integration with LangChain

[coming soon...]

## Contributing

There are four ways you can support this project:

1. Fork and Submit Pull Requests: We welcome any PRs that enhance the component or editor.
2. Open Issues: We appreciate reasonable suggestions and bug reports.
3. Donate: If this project has helped you, consider buying us a coffee using the Sponsor button at the top of the project. Cheers! ☕
4. Spread the Word: Recommend this project to others, star the repo, or add a backlink after using the project.

## Questions, Suggestions, Issues, or Bugs?

We use GitHub Issues to manage feedback. Feel free to open an issue, and we'll address it promptly.

## License

LGPL-3.0 or later

## Related Links

- Project repository: [github.com/gcui-art/suno-api](https://github.com/gcui-art/suno-api)
- Suno.ai official website: [suno.ai](https://suno.ai)
- Demo: [suno.gcui.ai](https://suno.gcui.ai)
- Album AI: [Auto generate image metadata and chat with the album. RAG + Album.](https://github.com/gcui-art/album-ai)

## Statement

suno-api is an unofficial open source project, intended for learning and research purposes only.

## 👋 Introduction

Suno.ai v3 is an amazing AI music service. Although the official API is not yet available, we couldn't wait to integrate its capabilities somewhere.

We discovered that some users have similar needs, so we decided to open-source this project, hoping you'll like it.

We update quickly, please star us on Github: [github.com/gcui-art/suno-api](https://github.com/gcui-art/suno-api) ⭐

## 🌟 Features

- Perfectly implements the creation API from `app.suno.ai`
- Compatible with the format of OpenAI’s `/v1/chat/completions` API.
- Automatically keep the account active.
- Supports `Custom Mode`
- One-click deployment to Vercel
- In addition to the standard API, it also adapts to the API Schema of Agent platforms like GPTs and Coze, so you can use it as a tool/plugin/Action for LLMs and integrate it into any AI Agent.
- Permissive open-source license, allowing you to freely integrate and modify.

## 🚀 Getting Started

### 1\. Obtain the cookie of your app.suno.ai account

1. Head over to [app.suno.ai](https://app.suno.ai/) using your browser.
2. Open up the browser console: hit `F12` or access the `Developer Tools`.
3. Navigate to the `Network tab`.
4. Give the page a quick refresh.
5. Identify the request that includes the keyword `client?_clerk_js_version`.
6. Click on it and switch over to the `Header` tab.
7. Locate the `Cookie` section, hover your mouse over it, and copy the value of the Cookie.

Your browser does not support frames.

### 2\. Clone and deploy this project

You can choose your preferred deployment method:

#### Deploy to Vercel

[![Deploy with Vercel](https://vercel.com/button)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2Fgcui-art%2Fsuno-api&env=SUNO_COOKIE&project-name=suno-api&repository-name=suno-api)

#### Run locally

```bash
git clone https://github.com/gcui-art/suno-api.git cd suno-api npm install
```

### 3\. Configure suno-api

- If deployed to Vercel, please add an environment variable `SUNO_COOKIE` in the Vercel dashboard, with the value of the cookie obtained in the first step.

- If you’re running this locally, be sure to add the following to your `.env` file:

    ```bash
    SUNO_COOKIE=<your-cookie>
    ```

### 4\. Run suno-api

- If you’ve deployed to Vercel:

  - Please click on Deploy in the Vercel dashboard and wait for the deployment to be successful.
  - Visit the `https://<vercel-assigned-domain>/api/get_limit` API for testing.
- If running locally:

  - Run `npm run dev`.
  - Visit the `http://localhost:3000/api/get_limit` API for testing.
- If the following result is returned:

    ```json
    { "credits_left": 50, "period": "day", "monthly_limit": 50, "monthly_usage": 50 }
    ```

it means the program is running normally.

### 5\. Use Suno API

You can check out the detailed API documentation at [suno.gcui.art/docs](https://suno.gcui.art/docs).

## 📚 API Reference

Suno API currently mainly implements the following APIs:

```bash
- `/api/generate`: Generate music - `/v1/chat/completions`: Generate music - Call the generate API in a format that works with OpenAI’s API. - `/api/custom_generate`: Generate music (Custom Mode, support setting lyrics, music style, title, etc.) - `/api/generate_lyrics`: Generate lyrics based on prompt - `/api/get`: Get music list - `/api/get?ids=`: Get music Info by id, separate multiple id with ",". - `/api/get_limit`: Get quota Info - `/api/extend_audio`: Extend audio length
```

For more detailed documentation, please check out the demo site:

👉 [suno.gcui.art/docs](https://suno.gcui.art/docs)

---

### default

It will automatically fill in the lyrics.

2 audio files will be generated for each request, consuming a total of 10 credits.

`wait_audio` can be set to API mode:

• By default, it is set to `false`, which indicates the background mode. It will only return audio task information, and you will need to call the get API to retrieve detailed audio information.

• If set to `true`, it simulates synchronous mode. The API will wait for a maximum of 100s until the audio is generated, and will directly return the audio link and other information. Recommend using in GPTs and other agents.

```json
{ "prompt": "A popular heavy metal song about war, sung by a deep-voiced male singer, slowly and melodiously. The lyrics depict the sorrow of people after the war.", "make_instrumental": false, "wait_audio": false }
```

| Code | Description | Links |
| --- | --- | --- |
| 200 |
success

<small>Media type</small>

<small>Controls <code>Accept</code> header.</small>

```json
[ { "0": { "id": "string", "title": "string", "image_url": "string", "lyric": "string", "audio_url": "string", "video_url": "string", "created_at": "string", "model_name": "string", "status": "string", "gpt_description_prompt": "string", "prompt": "string", "type": "string", "tags": "string" }, "1": { "id": "string", "title": "string", "image_url": "string", "lyric": "string", "audio_url": "string", "video_url": "string", "created_at": "string", "model_name": "string", "status": "string", "gpt_description_prompt": "string", "prompt": "string", "type": "string", "tags": "string" } } ]
```

 | *No links* |

Convert the `/api/generate` API to be compatible with the OpenAI `/v1/chat/completions` API format.

Generally used in OpenAI compatible clients.

```json
{ "prompt": "A popular heavy metal song about war, sung by a deep-voiced male singer, slowly and melodiously. The lyrics depict the sorrow of people after the war." }
```

| Code | Description | Links |
| --- | --- | --- |
| 200 |
success

<small>Media type</small>

<small>Controls <code>Accept</code> header.</small>

```json
{ "data": "string" }
```

 | *No links* |

The custom mode enables users to provide additional details about the music, such as music genre, lyrics, and more.

2 audio files will be generated for each request, consuming a total of 10 credits.

`wait_audio` can be set to API mode:

• By default, it is set to false, which indicates the background mode. It will only return audio task information, and you will need to call the get API to retrieve detailed audio information.

• If set to true, it simulates synchronous mode. The API will wait for a maximum of 100s until the audio is generated, and will directly return the audio link and other information. Recommend using in GPTs and other agents.

```json
{ "prompt": "[Verse 1]\nCruel flames of war engulf this land\nBattlefields filled with death and dread\nInnocent souls in darkness, they rest\nMy heart trembles in this silent test\n\n[Verse 2]\nPeople weep for loved ones lost\nBattered bodies bear the cost\nSeeking peace and hope once known\nOur grief transforms to hearts of stone\n\n[Chorus]\nSilent battlegrounds, no birds' song\nShadows of war, where we don't belong\nMay flowers of peace bloom in this place\nLet's guard this precious dream with grace\n\n[Bridge]\nThrough the ashes, we will rise\nHand in hand, towards peaceful skies\nNo more sorrow, no more pain\nTogether, we'll break these chains\n\n[Chorus]\nSilent battlegrounds, no birds' song\nShadows of war, where we don't belong\nMay flowers of peace bloom in this place\nLet's guard this precious dream with grace\n\n[Outro]\nIn unity, our strength will grow\nA brighter future, we'll soon know\nFrom the ruins, hope will spring\nA new dawn, we'll together bring", "tags": "pop metal male melancholic", "title": "Silent Battlefield", "make_instrumental": false, "wait_audio": false }
```

| Code | Description | Links |
| --- | --- | --- |
| 200 |
success

<small>Media type</small>

<small>Controls <code>Accept</code> header.</small>

```json
[ { "0": { "id": "string", "title": "string", "image_url": "string", "lyric": "string", "audio_url": "string", "video_url": "string", "created_at": "string", "model_name": "string", "status": "string", "gpt_description_prompt": "string", "prompt": "string", "type": "string", "tags": "string" }, "1": { "id": "string", "title": "string", "image_url": "string", "lyric": "string", "audio_url": "string", "video_url": "string", "created_at": "string", "model_name": "string", "status": "string", "gpt_description_prompt": "string", "prompt": "string", "type": "string", "tags": "string" } } ]
```

 | *No links* |

```json
{ "audio_id": "e76498dc-6ab4-4a10-a19f-8a095790e28d", "prompt": "", "continue_at": "109.96", "title": "", "tags": "" }
```

Generate lyrics based on Prompt.

```json
{ "prompt": "A soothing lullaby" }
```

| Code | Description | Links |
| --- | --- | --- |
| 200 |
success

<small>Media type</small>

<small>Controls <code>Accept</code> header.</small>

```json
{ "text": "string", "title": "string", "status": "string" }
```

 | *No links* |

| Name | Description |
| --- | --- |
|
ids

string

(query)

 |

Audio IDs, separated by commas. Leave blank to return a list of all music.

 |

| Code | Description | Links |
| --- | --- | --- |
| 200 |
success

<small>Media type</small>

<small>Controls <code>Accept</code> header.</small>

```json
[ { "0": { "id": "string", "title": "string", "image_url": "string", "lyric": "string", "audio_url": "string", "video_url": "string", "created_at": "string", "model_name": "string", "status": "string", "gpt_description_prompt": "string", "prompt": "string", "type": "string", "tags": "string" }, "1": { "id": "string", "title": "string", "image_url": "string", "lyric": "string", "audio_url": "string", "video_url": "string", "created_at": "string", "model_name": "string", "status": "string", "gpt_description_prompt": "string", "prompt": "string", "type": "string", "tags": "string" } } ]
```

 | *No links* |

| Code | Description | Links |
| --- | --- | --- |
| 200 |
success

<small>Media type</small>

<small>Controls <code>Accept</code> header.</small>

```json
{ "credits_left": 0, "period": "string", "monthly_limit": 0, "monthly_usage": 0 }
```

 | *No links* |

{

<table><tbody><tr><td>description:</td><td><p>Audio Info</p></td></tr><tr><td>id<span>*</span></td><td><span><span><span><span>string</span><p>audio id</p></span></span></span></td></tr><tr><td>title<span>*</span></td><td><span><span><span><span>string</span><p>music title</p></span></span></span></td></tr><tr><td>image_url<span>*</span></td><td><span><span><span><span>string</span><p>music cover image</p></span></span></span></td></tr><tr><td>lyric<span>*</span></td><td><span><span><span><span>string</span><p>music lyric</p></span></span></span></td></tr><tr><td>audio_url<span>*</span></td><td><span><span><span><span>string</span><p>music download url</p></span></span></span></td></tr><tr><td>video_url<span>*</span></td><td><span><span><span><span>string</span><p>Music video download link, can be used to share</p></span></span></span></td></tr><tr><td>created_at<span>*</span></td><td><span><span><span><span>string</span><p>Create time</p></span></span></span></td></tr><tr><td>model_name<span>*</span></td><td><span><span><span><span>string</span><p>suno model name, chirp-v3</p></span></span></span></td></tr><tr><td>status<span>*</span></td><td><span><span><span><span>string</span><p>The generated states include submitted, queue, streaming, complete.</p></span></span></span></td></tr><tr><td>gpt_description_prompt<span>*</span></td><td><span><span><span><span>string</span><p>Simple mode on user input prompt, Suno will generate formal prompts, lyrics, etc.</p></span></span></span></td></tr><tr><td>prompt<span>*</span></td><td><span><span><span><span>string</span><p>The final prompt for executing the generation task, customized by the user in custom mode, automatically generated by Suno in simple mode.</p></span></span></span></td></tr><tr><td>type<span>*</span></td><td><span><span><span><span>string</span><p>Type</p></span></span></span></td></tr><tr><td>tags<span>*</span></td><td><span><span><span><span>string</span><p>Music genre. User-provided in custom mode, automatically generated by Suno in simple mode.</p></span></span></span></td></tr></tbody></table>

}

================================================
File: suno.js
================================================

import *as fs from 'fs/promises';
import { parse } from 'node-html-parser';
import fetch from 'node-fetch';
import* as cheerio from 'cheerio'; // Use named import for cheerio
import path from 'path';

// Function to save song details as a markdown file
async function saveSongDetailsAsMarkdown(title, artist, tags, lyrics, coverImageUrl) {
    const markdownContent = `

# ${title}

### Artist: ${artist}

### Tags: ${tags}

### Release Year: ${new Date().getFullYear()}  <!-- Assuming current year, adjust if needed -->

## Lyrics

${lyrics}

![Cover Image](${coverImageUrl})

*Saved from Suno AI*
    `;

    const sanitizedTitle = title.replace(/[<>:"/\\|?*]+/g, '');
    const sanitizedArtist = artist.replace(/[<>:"/\\|?*]+/g, '');
    const markdownFilename = path.join('songs', `${sanitizedArtist} - ${sanitizedTitle}.md`);

    await fs.mkdir('songs', { recursive: true });
    await fs.writeFile(markdownFilename, markdownContent);
    console.log(`Saved markdown: ${markdownFilename}`);
}

// Function to process a Suno URL and extract metadata (without downloading the song)
async function processURL(url) {
    try {
        const uuid = url.match[/\b[0-9a-f]{8}\b-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-\b[0-9a-f]{12}\b/](0);
        const sunoURL = `https://suno.com/song/${uuid}`;
        const result = await fetch(sunoURL);

        if (!result.ok) {
            console.error('Failed to fetch:', sunoURL);
            return;
        }

        const html = await result.text();
        const $ = cheerio.load(html);

        // Extract the title (update the selector to match the actual page structure)
        const title = $('h1').text().trim() || 'Unknown Title';

        // Extract the artist (update selector to match actual artist container)
        const artist = $('.artist-name').text().trim() || 'Unknown Artist';

        // Extract the tags (update the selector if needed)
        const tags = $('.tags').text().trim() || 'No Tags';

        // Extract the lyrics (update selector to match the actual lyrics container)
        const lyrics = $('.lyrics').text().trim() || 'No Lyrics';

        // Extract cover image URL (update the selector as needed)
        const coverImageUrl = $('img.cover').attr('src') || '';

        // Save the extracted details as a markdown file
        await saveSongDetailsAsMarkdown(title, artist, tags, lyrics, coverImageUrl);
    } catch (error) {
        console.error(`An error occurred while processing ${url}:`, error);
    }
}

// Main function to handle multiple URLs
async function main() {
    const urls = process.argv.slice(2);

    if (!urls.length) {
        console.error('Please provide at least one Suno URL.');
        process.exit(1);
    }

    for (const url of urls) {
        if (!url.startsWith('https://suno.com/song/')) {
            console.warn(`Skipping invalid URL: ${url}`);
            continue;
        }
        await processURL(url);
    }
}

main();

================================================
File: suno.py
================================================

import requests
from bs4 import BeautifulSoup
import pandas as pd
import logging
import argparse
from urllib.parse import urljoin
import time

# Set up logging

logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(levelname)s - %(message)s')

def scrape_data(url, session):
    logging.info(f"Scraping URL: {url}")
    try:
        response = session.get(url, timeout=10)
        response.raise_for_status()
    except requests.RequestException as e:
        logging.error(f"Error fetching {url}: {e}")
        return None

    soup = BeautifulSoup(response.content, 'html.parser')

    # Define the selectors
    selectors = {
        "Title": "div.animate-marquee > a.whitespace-nowrap.mr-24",
        "Tags": ".md\\:mt-4 .font-sans.break-all.text-sm.text-primary.mr-1",
        "Metadata": "span.text-secondary.text-sm.font-sans",
        "Lyrics": "textarea[readonly]",
        "Cover": "img.absolute.inset-0.w-full.h-full.object-cover",
        "Link": "div.animate-marquee > a.whitespace-nowrap.mr-24"
    }

    data = {}

    # Extract Title
    title_element = soup.select_one(selectors['Title'])
    data['Title'] = title_element.get_text(
        strip=True) if title_element else None

    # Extract Tags
    tag_elements = soup.select(selectors['Tags'])
    data['Tags'] = ', '.join([tag.get_text(strip=True)
                             for tag in tag_elements]) if tag_elements else None

    # Extract Metadata
    metadata_elements = soup.select(selectors['Metadata'])
    data['Metadata'] = ', '.join([meta.get_text(
        strip=True) for meta in metadata_elements]) if metadata_elements else None

    # Extract Lyrics
    lyrics_element = soup.select_one(selectors['Lyrics'])
    data['Lyrics'] = lyrics_element.get_text(
        strip=True) if lyrics_element else None

    # Extract Cover image URL
    cover_element = soup.select_one(selectors['Cover'])
    if cover_element and cover_element.has_attr('src'):
        data['Cover'] = urljoin(url, cover_element['src'])
    else:
        data['Cover'] = None

    # Extract Link
    link_element = soup.select_one(selectors['Link'])
    if link_element and link_element.has_attr('href'):
        data['Link'] = urljoin(url, link_element['href'])
    else:
        data['Link'] = None

    return data

def main(input_file, output_file):
    # Read URLs from the input file
    with open(input_file, 'r') as file:
        urls = [line.strip() for line in file if line.strip()]

    if not urls:
        logging.error("No URLs found in the input file.")
        return

    # Initialize a session
    session = requests.Session()
    session.headers.update({'User-Agent': 'Mozilla/5.0 (compatible; Bot/1.0)'})

    # Scrape data from all URLs
    scraped_data = []
    for url in urls:
        data = scrape_data(url, session)
        if data:
            scraped_data.append(data)
        time.sleep(1)  # Polite crawling by adding a delay between requests

    # Create a DataFrame and save to CSV
    df = pd.DataFrame(scraped_data)
    df.to_csv(output_file, index=False)

    logging.info(f"Data scraped and saved to {output_file}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Scrape data from URLs and save to CSV.")
    parser.add_argument('--input', required=True,
                        help="Input file containing URLs")
    parser.add_argument(
        '--output', default='scraped_data.csv', help="Output CSV file")

    args = parser.parse_args()

    main(args.input, args.output)

================================================
File: suno_downloader.py
================================================

from playwright.sync_api import sync_playwright
import os
import re
import requests
from bs4 import BeautifulSoup
from mutagen.id3 import ID3, USLT, APIC, ID3NoHeaderError

# Ensure the Logs folder exists

os.makedirs("Logs", exist_ok=True)

# Global variables for timeouts (in milliseconds) – will be set in main()

NAV_TIMEOUT = 60000       # default: 60 seconds (will be updated)
SELECTOR_TIMEOUT = 20000  # default: 20 seconds (will be updated)

# Global log file (inside Logs folder relative to script location) and a dictionary for failure details

LOG_FILE = os.path.join("Logs", "suno_operation_log.txt")
failures = {}  # Stores detailed failure messages per URL.

# Ensure the 'Logs' directory exists

if not os.path.exists('Logs'):
    os.makedirs('Logs')

# Global flag for overwriting files (set by the user at the start)

OVERWRITE_FILES = False

def log_operation(message):
    """Appends a message to the operation log file and prints it."""
    with open(LOG_FILE, "a", encoding="utf-8") as f:
        f.write(message + "\n")
    print(message)

def initialize_files(skip_file, failed_file):
    """
    Ensures that the skip and failed files exist.
    If they do not exist, they are created with an initial header.
    """
    if not os.path.exists(skip_file):
        with open(skip_file, "w", encoding="utf-8") as f:
            f.write("Suno URLs SKIPPED:\n")
        log_operation(f"Created skip file: {skip_file}")
    if not os.path.exists(failed_file):
        with open(failed_file, "w", encoding="utf-8") as f:
            f.write("Suno URLs FAILED:\n")
        log_operation(f"Created failed file: {failed_file}")

def read_urls_from_file(file_path):
    """Reads URLs from a file, ignoring empty lines."""
    if not os.path.exists(file_path):
        log_operation(f"❌ File not found: {file_path}")
        return []
    with open(file_path, "r", encoding="utf-8") as f:
        return [line.strip() for line in f if line.strip()]

def sanitize_filename(filename):
    """Replaces illegal filename characters with an underscore."""
    return re.sub(r'[<>:"/\\|?*]', '_', filename)

def record_failure(url, message):
    """Records a failure message for a given URL in the global dictionary and logs it."""
    if url not in failures:
        failures[url] = []
    failures[url].append(message)
    log_operation(f"[{url}] FAILURE: {message}")

def extract_gpt_prompt(html):
    """
    Attempts to extract the GPT prompt from the HTML source.
    Searches for a JSON fragment with "gpt_description_prompt" (removing the trailing phrase)
    and falls back to the 3rd <meta> tag with a content attribute.
    """
    soup = BeautifulSoup(html, "html.parser")
    for script in soup.find_all("script"):
        script_text = script.get_text()
        if "gpt_description_prompt" in script_text:
            match = re.search(r'"gpt_description_prompt"\s*:\s*\\"?([^\\"]+)\\"?', script_text)
            if match:
                prompt = match.group(1).strip()
                prompt = prompt.replace(" song. Listen and make your own with Suno.", "").strip()
                if prompt:
                    return prompt
    meta_tags = soup.find_all("meta", attrs={"content": True})
    if len(meta_tags) >= 3:
        fallback_prompt = meta_tags[2].get("content", "").strip()
        fallback_prompt = fallback_prompt.replace(" song. Listen and make your own with Suno.", "").strip()
        if fallback_prompt:
            return fallback_prompt
    return None

def extract_page_data(url):
    """
    Uses Playwright to load the page at the given URL and extract:
      - The page title (for filenames)
      - The lyrics text (using the CSS selector "section.w-full > div:nth-child(1)")
      - The full HTML content
      - The GPT prompt (via extract_gpt_prompt)
    Timeouts for navigation and selectors are set by the global variables.
    """
    global NAV_TIMEOUT, SELECTOR_TIMEOUT
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        page = browser.new_page()
        log_operation(f"⏳ Navigating to {url}...")
        try:
            page.goto(url, timeout=NAV_TIMEOUT)
        except Exception as e:
            msg = f"Error navigating to {url}: {e}"
            log_operation(f"❌ {msg}")
            record_failure(url, msg)
            browser.close()
            return "Unknown_Song", None, None, None
        try:
            page.wait_for_selector("section.w-full > div:nth-child(1)", timeout=SELECTOR_TIMEOUT)
            lyrics = page.text_content("section.w-full > div:nth-child(1)").strip()
        except Exception as e:
            msg = f"Error extracting lyrics from {url}: {e}"
            log_operation(f"❌ {msg}")
            record_failure(url, msg)
            lyrics = None
        title = page.title() or "Unknown_Song"
        html_content = page.content()
        gpt_prompt = extract_gpt_prompt(html_content)
        if not gpt_prompt:
            record_failure(url, "GPT prompt not found")
        browser.close()
        return title, lyrics, gpt_prompt, html_content

def save_text_to_file(text, directory, filename):
    """
    Saves the given text to a file in the specified directory.
    If OVERWRITE_FILES is False and the file exists, appends a number.
    """
    os.makedirs(directory, exist_ok=True)
    filepath = os.path.join(directory, filename)
    if not OVERWRITE_FILES:
        base, ext = os.path.splitext(filename)
        counter = 1
        while os.path.exists(filepath):
            filepath = os.path.join(directory, f"{base} ({counter}){ext}")
            counter += 1
    with open(filepath, "w", encoding="utf-8") as f:
        f.write(text)
    log_operation(f"✅ Saved to {filepath}")

def download_file(url, directory, filename, extension):
    """
    Downloads a file from the provided URL using Requests and saves it
    in the specified directory with the given filename and extension.
    If OVERWRITE_FILES is False and the file exists, appends a number.
    Returns the final file path on success, or None on failure.
    """
    if not url:
        msg = f"URL not provided for {filename}.{extension}"
        log_operation(f"⚠️ {msg}")
        return None
    os.makedirs(directory, exist_ok=True)
    filepath = os.path.join(directory, f"{filename}.{extension}")
    if not OVERWRITE_FILES:
        counter = 1
        while os.path.exists(filepath):
            filepath = os.path.join(directory, f"{filename} ({counter}).{extension}")
            counter += 1
    try:
        response = requests.get(url, stream=True, timeout=15)
        response.raise_for_status()
        with open(filepath, "wb") as f:
            for chunk in response.iter_content(chunk_size=8192):
                f.write(chunk)
        log_operation(f"✅ Downloaded file to {filepath}")
        return filepath
    except Exception as e:
        msg = f"Failed to download {url}: {e}"
        log_operation(f"❌ {msg}")
        record_failure("", msg)
        return None

def add_lyrics_to_mp3(mp3_filepath, lyrics):
    """
    Adds the provided lyrics to the MP3 file's ID3 tag (USLT frame).
    Overwrites any existing lyrics.
    """
    try:
        try:
            audio = ID3(mp3_filepath)
        except ID3NoHeaderError:
            audio = ID3()
        audio.delall("USLT")
        audio.add(USLT(encoding=3, desc=u"lyrics", text=lyrics))
        audio.save(mp3_filepath)
        log_operation(f"✅ Added lyrics to MP3 tag for {mp3_filepath}")
    except Exception as e:
        msg = f"Error adding lyrics to MP3 tag for {mp3_filepath}: {e}"
        log_operation(f"❌ {msg}")
        record_failure("", msg)

def add_image_to_mp3(mp3_filepath, image_filepath):
    """
    Embeds the image (from image_filepath) into the MP3 file's ID3 tag (APIC frame).
    Overwrites any existing album art.
    """
    try:
        try:
            audio = ID3(mp3_filepath)
        except ID3NoHeaderError:
            audio = ID3()
        with open(image_filepath, "rb") as img:
            img_data = img.read()
        audio.delall("APIC")
        audio.add(APIC(
            encoding=3,
            mime="image/jpeg",
            type=3,
            desc="Cover",
            data=img_data
        ))
        audio.save(mp3_filepath)
        log_operation(f"✅ Embedded image into MP3 tag for {mp3_filepath}")
    except Exception as e:
        msg = f"Error embedding image into MP3 tag for {mp3_filepath}: {e}"
        log_operation(f"❌ {msg}")
        record_failure("", msg)

session = requests.Session()

def get_user_selection():
    """
    Prompts the user to select what to extract and save for each URL.
    Options:
      1. HTML
      2. MP4
      3. MP3
      4. Lyrics
      5. Prompt
      6. Image
      7. Add index (prefix filenames with a padded 5-digit number)
      8. All of 1-6 (extraction options only)
      9. All of 1-7 (extraction options plus indexing)
    """
    print("Select what to extract and save for each URL:")
    print("1. HTML")
    print("2. MP4")
    print("3. MP3")
    print("4. Lyrics")
    print("5. Prompt")
    print("6. Image")
    print("7. Add index (prefix filenames with a padded 5-digit number)")
    print("8. All of 1-6 (extraction options only)")
    print("9. All of 1-7 (extraction options plus indexing)")
    choices = input("Enter numbers separated by commas (e.g., 1,2,4,5,6): ")
    selections = [x.strip() for x in choices.split(",")]
    sel = {
        "html": False,
        "mp4": False,
        "mp3": False,
        "lyrics": False,
        "prompt": False,
        "image": False,
        "index": False
    }
    if "8" in selections:
        sel["html"] = sel["mp4"] = sel["mp3"] = sel["lyrics"] = sel["prompt"] = sel["image"] = True
    if "9" in selections:
        sel["html"] = sel["mp4"] = sel["mp3"] = sel["lyrics"] = sel["prompt"] = sel["image"] = True
        sel["index"] = True
    if "1" in selections: sel["html"] = True
    if "2" in selections: sel["mp4"] = True
    if "3" in selections: sel["mp3"] = True
    if "4" in selections: sel["lyrics"] = True
    if "5" in selections: sel["prompt"] = True
    if "6" in selections: sel["image"] = True
    if "7" in selections: sel["index"] = True
    return sel

def retry_failed_urls(failed_urls, options):
    """Retries processing for the URLs in failed_urls once."""
    if not failed_urls:
        log_operation("✅ No failed URLs to retry.")
        return
    log_operation("\n🔄 Retrying failed URLs...")
    still_failed = set()
    for url in failed_urls:
        log_operation(f"🔄 Retrying URL: {url}")
        title, lyrics, gpt_prompt, html_content = extract_page_data(url)
        sanitized_title = sanitize_filename(title)
        if options["html"]:
            if html_content:
                save_text_to_file(html_content, "HTML", f"{sanitized_title} - Parsed.html")
            else:
                msg = "HTML content not found on retry"
                log_operation(f"⚠️ {msg}")
                record_failure(url, msg)
                still_failed.add(url)
        if options["lyrics"]:
            if lyrics:
                save_text_to_file(lyrics, "Lyrics", f"{sanitized_title} - Lyrics.txt")
            else:
                msg = "Lyrics not found on retry"
                log_operation(f"⚠️ {msg}")
                record_failure(url, msg)
                still_failed.add(url)
        if options["prompt"]:
            if gpt_prompt:
                save_text_to_file(gpt_prompt, "Prompts", f"{sanitized_title} - Prompt.txt")
            else:
                msg = "GPT prompt not found on retry"
                log_operation(f"⚠️ {msg}")
                record_failure(url, msg)
                still_failed.add(url)
        try:
            response = session.get(url, timeout=15)
            response.raise_for_status()
            soup = BeautifulSoup(response.content, "html.parser")
        except Exception as e:
            msg = f"Error fetching full HTML for media extraction on retry: {e}"
            log_operation(f"❌ {msg}")
            record_failure(url, msg)
            still_failed.add(url)
            continue
        if options["mp4"]:
            video_meta = soup.find("meta", {"property": "og:video:url"})
            video_url = video_meta.get("content") if video_meta else None
            if video_url:
                if not download_file(video_url, "Videos", sanitized_title, "mp4"):
                    still_failed.add(url)
            else:
                msg = "Video URL not found on retry"
                log_operation(f"⚠️ {msg}")
                record_failure(url, msg)
                still_failed.add(url)
        if options["mp3"]:
            audio_meta = soup.find("meta", {"property": "og:audio"})
            audio_url = audio_meta.get("content") if audio_meta else None
            if audio_url:
                mp3_filepath = download_file(audio_url, "Audio", sanitized_title, "mp3")
                if not mp3_filepath:
                    still_failed.add(url)
                else:
                    if lyrics:
                        add_lyrics_to_mp3(mp3_filepath, lyrics)
            else:
                msg = "Audio URL not found on retry"
                log_operation(f"⚠️ {msg}")
                record_failure(url, msg)
                still_failed.add(url)
        if options["image"]:
            image_meta = soup.find("meta", {"name": "twitter:image"})
            if image_meta:
                img_url = image_meta.get("content")
                if "image_large_" not in img_url:
                    image_meta = soup.find("meta", {"property": "og:image"})
                    img_url = image_meta.get("content") if image_meta else None
            else:
                image_meta = soup.find("meta", {"property": "og:image"})
                img_url = image_meta.get("content") if image_meta else None
            if img_url:
                image_filepath = download_file(img_url, "Images", sanitized_title + " - Art", "jpeg")
                if not image_filepath:
                    still_failed.add(url)
            else:
                msg = "Image URL not found on retry"
                log_operation(f"⚠️ {msg}")
                record_failure(url, msg)
                still_failed.add(url)
    if still_failed:
        log_operation("\n❌ The following URLs still failed after retry:")
        for url in still_failed:
            log_operation(url)
        with open("suno_urls_FAILED.txt", "a", encoding="utf-8") as f:
            f.write("Final failure details for this run:\n")
            for url in still_failed:
                f.write(url + "\n")
    else:
        log_operation("\n✅ All previously failed URLs succeeded on retry.")

def main():
    # Files for URLs and tracking.
    urls_file = "suno_urls.txt"             # File with URLs (one per line)
    skip_file = "suno_urls_SKIPPED.txt"       # File to keep track of processed URLs
    failed_file = "suno_urls_FAILED.txt"      # File to store failure details

    # Ensure that the skip and failed files exist.
    initialize_files(skip_file, failed_file)

    # Prompt the user whether to overwrite files.
    overwrite_choice = input("Do you want to overwrite files if they already exist? (Y/N): ").strip().upper()
    global OVERWRITE_FILES
    if overwrite_choice == "Y":
        OVERWRITE_FILES = True
        log_operation("Files will be overwritten if they exist.")
    else:
        OVERWRITE_FILES = False
        log_operation("Files will not be overwritten; duplicates will have appended numbers.")

    # Read already processed URLs.
    downloaded_set = set()
    if os.path.exists(skip_file):
        with open(skip_file, "r", encoding="utf-8") as f:
            for line in f:
                downloaded_set.add(line.strip())

    options = get_user_selection()

    # Prompt for timeouts (in seconds), then convert to milliseconds.
    try:
        nav_timeout_input = input("Enter timeout1 in seconds for page navigation: (Default 60)")
        nav_timeout_seconds = float(nav_timeout_input)
    except Exception:
        nav_timeout_seconds = 60
    try:
        selector_timeout_input = input("Enter timeout2 in seconds for waiting for selectors: (Default 20)")
        selector_timeout_seconds = float(selector_timeout_input)
    except Exception:
        selector_timeout_seconds = 20
    global NAV_TIMEOUT, SELECTOR_TIMEOUT
    NAV_TIMEOUT = int(nav_timeout_seconds * 1000)
    SELECTOR_TIMEOUT = int(selector_timeout_seconds * 1000)
    log_operation(f"Timeout settings: Navigation = {NAV_TIMEOUT} ms, Selector = {SELECTOR_TIMEOUT} ms")

    if options["index"]:
        current_index = len(downloaded_set)
    else:
        current_index = None

    urls = read_urls_from_file(urls_file)
    if not urls:
        log_operation("❌ No URLs found in the file.")
        return

    failed_urls = set()

    for url in urls:
        if url in downloaded_set:
            log_operation(f"Skipping URL (already processed): {url}")
            continue

        log_operation(f"🔄 Processing URL: {url}")
        if options["index"]:
            current_index += 1
            index_prefix = f"{current_index:05d} - "
        else:
            index_prefix = ""

        title, lyrics, gpt_prompt, html_content = extract_page_data(url)
        sanitized_title = sanitize_filename(title)

        if options["html"]:
            if html_content:
                save_text_to_file(html_content, "HTML", f"{index_prefix}{sanitized_title} - Parsed.html")
            else:
                record_failure(url, "HTML content not found")
                failed_urls.add(url)

        if options["lyrics"]:
            if lyrics:
                save_text_to_file(lyrics, "Lyrics", f"{index_prefix}{sanitized_title} - Lyrics.txt")
            else:
                record_failure(url, "Lyrics not found")
                failed_urls.add(url)

        if options["prompt"]:
            if gpt_prompt:
                save_text_to_file(gpt_prompt, "Prompts", f"{index_prefix}{sanitized_title} - Prompt.txt")
            else:
                record_failure(url, "GPT prompt not found")
                failed_urls.add(url)

        try:
            response = session.get(url, timeout=15)
            response.raise_for_status()
            soup = BeautifulSoup(response.content, "html.parser")
        except Exception as e:
            record_failure(url, f"Error fetching full HTML for media extraction: {e}")
            failed_urls.add(url)
            continue

        # MP4 extraction block added here.
        if options["mp4"]:
            video_meta = soup.find("meta", {"property": "og:video:url"})
            video_url = video_meta.get("content") if video_meta else None
            if video_url:
                video_filepath = download_file(video_url, "Videos", f"{index_prefix}{sanitized_title}", "mp4")
                if not video_filepath:
                    record_failure(url, "Failed to download video")
                    failed_urls.add(url)
            else:
                record_failure(url, "Video URL not found")
                failed_urls.add(url)

        # MP3 extraction
        current_mp3_filepath = None
        if options["mp3"]:
            audio_meta = soup.find("meta", {"property": "og:audio"})
            audio_url = audio_meta.get("content") if audio_meta else None
            if audio_url:
                current_mp3_filepath = download_file(audio_url, "Audio", f"{index_prefix}{sanitized_title}", "mp3")
                if not current_mp3_filepath:
                    failed_urls.add(url)
                else:
                    if lyrics:
                        add_lyrics_to_mp3(current_mp3_filepath, lyrics)
            else:
                record_failure(url, "Audio URL not found")
                failed_urls.add(url)

        # Image extraction
        current_image_filepath = None
        if options["image"]:
            image_meta = soup.find("meta", {"name": "twitter:image"})
            if image_meta:
                img_url = image_meta.get("content")
                if "image_large_" not in img_url:
                    image_meta = soup.find("meta", {"property": "og:image"})
                    img_url = image_meta.get("content") if image_meta else None
            else:
                image_meta = soup.find("meta", {"property": "og:image"})
                img_url = image_meta.get("content") if image_meta else None
            if img_url:
                current_image_filepath = download_file(img_url, "Images", f"{index_prefix}{sanitized_title} - Art", "jpeg")
                if not current_image_filepath:
                    failed_urls.add(url)
            else:
                record_failure(url, "Image URL not found")
                failed_urls.add(url)

        # If both MP3 and image were downloaded successfully, embed the image into the MP3.
        if options["mp3"] and options["image"] and current_mp3_filepath and current_image_filepath:
            add_image_to_mp3(current_mp3_filepath, current_image_filepath)

        # If no failures for this URL, immediately update the skip file.
        if url not in failed_urls:
            with open(skip_file, "a", encoding="utf-8") as sf:
                sf.write(url + "\n")
            downloaded_set.add(url)
            log_operation(f"✅ Marked URL as processed: {url}")

    if failures:
        with open(failed_file, "a", encoding="utf-8") as f:
            f.write("Final failure details for this run:\n")
            for url, msgs in failures.items():
                f.write(f"URL: {url}\n")
                for msg in msgs:
                    f.write(f"  - {msg}\n")
                f.write("\n")
        log_operation(f"\n❌ Failure details have been appended to {failed_file}")
    else:
        log_operation("\n✅ No failures recorded.")

    retry_failed_urls(failed_urls, options)

if __name__ == "__main__":
    main()

================================================
File: sunomegathread.md
================================================

# __Megathread Summary: Suno Tips and Tricks__

This Reddit megathread is a community-driven collection of advice, techniques, and troubleshooting for using the AI music generation service, Suno. It covers a wide range of topics, from basic usage to advanced prompt engineering and integration with other tools.  Key areas discussed include:

- __Lyric Structure and Punctuation:__
  - Punctuation significantly influences the AI's interpretation of pacing and emphasis.  Sparse punctuation is more effective than correct punctuation.
  - Commas create short pauses, ellipses create longer pauses.
  - Quotation marks can alter voice, accent, or style.
  - Capitalization emphasizes words or phrases.
  - Structuring lines (e.g., run-on sentences for faster flow) can influence the musical style.

- __Vocal Control and Effects:__
  - Achieving "dual lyrics" (two voices singing different lyrics simultaneously) is challenging. "Layered vocals" in the style prompt is suggested.
  - Specific vocal styles (e.g., "minimal lyrical singing, sparse humming") can be requested.
  - Techniques for adding screams and other vocalizations are discussed, including using brackets (e.g., `[(guttural scream)]`) and capitalization.
  - Using foreign language characters to get a non standard accent, by writing the lyrics with foreign characters, remastering and changing the lyrics to the standard character.

- __Prompt Engineering:__
  - Using specific musical terms (BPM, pitch, voice style) can improve results.
  - Referencing musical styles rather than specific artists (e.g., "Zimmer-core" instead of "Hans Zimmer") is recommended.
  - Using "exclude styles" can help avoid unwanted elements.
  - Using random strings (from QRNG generators) can introduce variety.

- __Genre and Style Manipulation:__
  - Experimenting with unusual genre combinations (e.g., "Hindi Boombap") is encouraged.
  - Specifying instrumentation (e.g., "instrumental-heavy") can influence the output.
  - Requests for specific regional styles (like a Mexican "grito") are discussed, with varying success.

- __Integration with Other Tools:__
  - __ChatGPT:__ Used for generating lyrics, formatting prompts, exploring song styles, and analyzing existing songs. Several custom GPTs are specifically designed for Suno.
  - __Audio Editing Software (Audacity, Serato Studio, djay Pro):__ Used for stem separation (isolating vocals and instrumentals), and general audio post processing.
  - __Stem Separation Tools (Open Vino Music Separation Plugin, Ultimate Vocal Remover):__ Mentioned as alternatives for isolating vocals and instruments.
  - __Cyanite.ai, Sonoteller.ai, Music.ai:__ Used for analyzing the genre, style, and other metadata of existing songs to inform Suno prompts.
  - __Neural Frames:__ For turning song into music videos.

- __Troubleshooting and Workarounds:__
  - Download issues are sometimes resolved by disabling VPNs.
  - Voice changes during song extensions are acknowledged as a limitation of the underlying machine learning models.
  - The "metallic hiss" or lack of dynamics in some Suno outputs is discussed.
  - Techniques for reducing the prominence of certain instruments (e.g., synth solos) are explored.
  - Workarounds for monetizing songs created with a free account are discussed (e.g., extending and modifying the song).

- __General Tips and Observations:__
  - Suno's interpretation of lyrics and prompts can be unpredictable.
  - The AI may sometimes insert unexpected elements (e.g., radio breaks, profanity).
  - Credits may expire, and users report losing credits.
  - The community debates the balance between sharing songs and providing explanations of how they were created.
  - Using Suno in conjunction with ChatGPT for lyric and structure generation often provides better, more coherent results.
  - Experimentation and iterative refinement are key to achieving desired outcomes.

- __Credit Loss:__
  - Reports of users losing credits.

- __Advanced editing__
  - How to improve the sound of generated music.

__External URLs (Outside of Reddit):__

1. __`https://sunoaiwiki.com/de/tips/2024-05-04-how-to-structure-prompts-for-suno-ai/`__ - A wiki page (in German) with tips on structuring prompts for Suno.

2. __`http://uvronline.com`__ - Ultimate Vocal Remover online tool for testing stem separation models.

3. __`https://chatgpt.com/g/g-673d599e7f3481919b279aac3e71327d-suno-v4-master`__ - Link to a custom ChatGPT GPT ("SUNOv4 Master") designed to help with Suno prompts.

4. __`https://chatgpt.com/g/g-6771ab4181e88191b8676ba5371adcc1-suno-reduex-lyric-model`__ - Link to another custom GPT ("Suno ReDeux Lyric Master") for lyric generation.

5. __`https://www.neuralframes.com/?via=chatgpt`__ - A service for creating music videos.

6. __`https://suno.com/song/e97e06ca-5208-447c-a583-ac8be6968674`__ - Link to a specific Suno song, used as an example.

7. __`https://suno.com/invite/@severeguitarriff753`__ - A Suno invite link.

8. __`https://qrng.anu.edu.au/random-block-alpha/`__ - A quantum random number generator, used for adding variety to prompts.

9. __`https://www.udio.com/songs/dgDgYqj4L71Y69YB7iVifz`__ - Example song on Udio, another AI music generation platform.

10. __`https://suno.com/song/df69dfbe-6f3e-49dc-b218-d25229506467`__ - Example Suno song with foreign characters in the lyrics.

11. __`https://suno.com/song/9df21ab2-e06f-45df-9841-825de8c808a4`__ - Example Suno song, remastered with standard characters.

12. __`https://music.youtube.com/watch?v=hmL_9RFly2Mandlist=OLAK5uy_kDU99ScT7V7fjyiAyFEoP51fJD2MrU7z8`__ - YouTube Music link to a song ("The_Ænigma_Express") created using the foreign character technique.

13. __`https://music.youtube.com/watch?v=KHZfPyW11HAandlist=OLAK5uy_kDU99ScT7V7fjyiAyFEoP51fJD2MrU7z8`__ - YouTube Music link to another song ("Hæstens_Dreams") using the same technique.

14. __`https://chatgpt.com/share/675e7ca8-49c4-800b-b9db-37627abe48ad`__ - Shared ChatGPT link for exploring song styles.

15. __`https://www.youtube.com/watch?v=0MCLvzWB8t8`__ - YouTube guide on using custom vocal samples in Suno.

16. __`https://cyanite.ai`__ - A tool for analyzing music and identifying genres/styles.

17. __`https://sonoteller.ai/`__ - Another tool for analyzing music, specifically from YouTube links.

18. __`https://preview.redd.it/zpqhsorxa7ee1.jpeg?width=1080andformat=pjpgandauto=webpands=8020c9ebbd228cc2c565531465bc514277cd2f11`__ - Reddit image showing that Music.ai uses Cyanite.

19. __`https://chatgpt.com/g/g-BTzqvfjLQ-suno-custom-song-prompt-creator`__ - A ChatGPT GPT for creating Suno prompts based on various inputs.

20. __`https://suno.com/song/3b2c11f7-311a-4eb6-982e-41ca60d1c35e`__ - Example Suno song ("Fever") with an unexpected radio break.

21. __`https://suno.com/song/1a71f5a7-032b-4eef-ad9a-1b6e3287473c`__ - Example Suno song in the style of Juice WRLD, Lil Peep, etc.

22. __`https://suno.com/song/1d86a7a7-3d5e-41d6-965b-5779ddf545b1`__ - Another example of a similar style.

23. __`https://suno.com/song/ddb7be3a-fc5c-43fd-b6c5-86f724d83258`__ - Example Suno song with minimal instrumentation.

24. __`https://i.imgur.com/oWxIzs1.png`__ - Image showing an Audacity filter curve EQ setting for improving vocal clarity.

25. __`https://www.suno.wiki/faq/making-music/why-cant-i-hear-my-lyrics/`__ - Suno Wiki FAQ page addressing issues with missing lyrics.

26. __`https://suno.com/playlist/7cec79f8-bfc6-4d9f-883f-6dcfe9685346`__ -  Example of instrumental playlist.

27. __`https://suno.com/song/71f7f627-f2fc-4d55-aff7-623dc82ce4ea`__ - Example of instrumental song.

28. __`https://suno.com/@spellbindingnocturne883`__ - A Suno user's profile with a large number of songs.  (This URL appears multiple times)

29. __`https://suno.com/song/5ce6900e-51a1-4072-b370-b8e9d54fcd41`__ - Example song created using ChatGPT for guidance.
30. __`https://udio.com`__-better sound quality, less interesting songs.
This comprehensive list captures all the external links and the main points of discussion within the megathread, providing a useful resource for anyone looking to improve their Suno AI music creation skills.

---

# THE SECRET TO CREATING GOOD SUNO MUSIC

__Summary:__

This post and its comments focus on improving the quality of music generated by Suno AI by emphasizing lyrical quality, structure, and detailed prompting.  The main points are:

- __Lyric Quality is Key:__ The core message is that good lyrics, stories, hooks, and "lyrical conversations" are essential.  Don't rely solely on Suno's generic lyric generation.

- __Structure and Directional Prompts:__ Use a clear song structure (intro, verse, chorus, bridge, outro) and include specific commands within the lyrics section using double brackets `[[ ]]` to guide the AI.  Examples include `[[Harmonize female vocals]]`, `[[chop, layer, echo, reverb, attack]]`, and `[[Vocal ad-libs]]`. These prompts are placed *within* the lyric section, at the beginning of relevant parts.

- __Genre-Specific Advice (for Electronic Music):__ For genres like house, EDM, future bass, and D&B, the author suggests that only a few lines of lyrics are needed.  Focus on a catchy hook and "call and response" lines.

- __Persona and Character:__ Give the AI "personas" accents and character traits in the style description (e.g., "soulful uplifting sultry female vocal with husky British voice"). This can help with later NFT/tokenization efforts (though this is not explained further).

- __Duets and Vocal Interaction:__  Create duets by specifying which voice should sing which line (e.g., `[Male]`, `[Female]`, `[Together]`).  "Call and response" prompts are also recommended. There are various ways users have found to make duets using the prompt and lyric area, such as, `[[MALE VOICE] (FEMALE VOICE)]]` and prompting `Lyrics here(lyrics here)`.

- __Using 3rd Party AI for Assistance:__  Use other AI tools (implied: ChatGPT or similar) to help craft song structure.  Don't accept the AI's first suggestion; refine it by asking for more soulful, uplifting, or gritty results.  Then, *humanize* the AI-generated lyrics by changing words and adding colloquialisms.  This is presented as a way to *learn* lyric writing, not as a replacement for it.

- __Vocal Techniques:__ Learn about singing styles, rapping techniques, and the language of lyricism.  Specific vocal terms like "rubato," "melismatic," and Italian musical terms are mentioned.

- __Ending the Song:__  Use prompts like `[[Beats fade out echo clean]]` to prevent abrupt endings.

- __"HD Quality studio Production"__:  Try adding this to the style box.

- __Double Brackets [[ ]]__: The author consistently uses double brackets for in-lyric commands, claiming that single brackets `[]` or parentheses `()` can be misinterpreted by Suno as lyrics.

- __Experimentation:__  The overall tone encourages experimentation and pushing the AI beyond its default tendencies.  The results are not always perfect, and multiple attempts may be needed.

- __BPM Control__: You can specify a tempo by using `[TEMPO:80BPM]`.

- __Drum Control__ - How to start a song with drums and slowly add more musical elements throughout the progression of the song.

__External URLs (Outside of Reddit):__

1. __`https://suno.com/song/4b92f438-ac28-4710-b4a8-4c9b8fcf388e`__:  An example Suno song demonstrating a duet triggered by the phrase "lyrical counter-melody" in Verse 2.

2. __`https://open.spotify.com/track/2Ompx6uQfyGKYtIIm5Lgz0?si=rVWt8sbiSB2ofpfoTydYvA`__: A Spotify link to a song presented as an example of a duet created using Suno.

3. __`https://suno.com/song/f870afa0-2595-4973-8907-0e28f829f7ec`__:  Another example Suno song, demonstrating the techniques discussed in the post.

4. __`https://open.spotify.com/album/0CaGBUKyYTeb2jMIhxX0Er?si=bz8wHBrBTlGoJlN0a8MXWg`__: A spotify album created by the commenter, showcasing lyrics he wrote.

5. __`https://www.reddit.com/user/CharmingAd2038/comments/1irjoi3/delete_the_elite/?utm_source=share&utm_medium=mweb3x&utm_name=mweb3xcss&utm_term=1&utm_content=share_button`__: A Reddit post (by the original poster) showcasing a hip-hop track created using the described methods. This URL is used twice.

---

# A guide for creating better and more consistent songs

__Summary:__

This post provides advice from an experienced Suno user who has released an album created using the AI.  The focus is on achieving consistency and maximizing the strengths of different Suno versions.

- __Intro and First Verse are Crucial:__  These sections set the tone for the entire song.
- __Qualifying Tags for Vocals:__ Use detailed tags like `[Smooth Sensual Female Vocal]` both before each verse and in the overall style tags section to ensure consistent vocal style throughout the song.
- __Abuse Tags for Layers and Control:__ Use tags within the lyrics section to specify musical elements, like `[Bluesy Guitar Arpeggio]` or `[Smooth Bass Line]`.  This gives more fine-grained control over the instrumentation.
- __Onomatopoeia for Complex Effects:__ Use sounds written out (e.g., "...eeeeeennnnnn...") within tags to describe and influence sustained notes or other effects.  Example: `[Sitar, single sustained note, shimmering with vibrato] (e.g., “…eeeeeennnnnn…”)`.
- __Leverage v3.5 and v4:__
  - v3.5 is generally better for song structure, instrumentals, and overall stability.
  - v4 typically produces better vocals.
  - The recommended workflow is to generate the full song in v3.5 and then *remaster* it in v4 to get the improved vocals.
- __Always Extend from the Full Song:__ When using the "Extend" feature, always start from the complete generated song.  Extending from a partial section limits Suno's understanding of the overall context.
- __"Hallucinated" songs method__:
  - Create a song with no lyrics, let it generate a melody.
  - Find a performance you like.
  - Use "replace" on the first section with your lyrics and extend from there.

__External URLs (Outside of Reddit):__

1. __`https://open.spotify.com/track/0KKGeq1zlMUoTrvhrqPslo?si=r2rPaAoSRKKbo1ra-bGQbg`__:  A Spotify link to one of the songs from the author's album, presented as an example of the techniques described.

2. __`https://suno.com/song/2cd49b69-0368-4eed-a0a7-243b2fc04b40`__: A Suno link to an example of a "hallucinated" song (generated with nonsense lyrics) used as a starting point.

3. __`https://suno.com/song/6d5582e5-b83a-436b-be5e-4efef96f9d5a`__: A Suno link to a finished song created by writing lyrics to fit the "hallucinated" song above.

4. __`https://suno.com/song/2cc4735e-5522-4ccc-8b37-d6c35c534a0c`__: A Suno link to an example of an instrumental melody created first, with lyrics added later.

5. __`https://suno.com/song/c36bd50e-3ea2-4902-85f2-59c7c0f9c454`__:  A Suno link to a song generated with nonsense words.

6. __`https://suno.com/song/9e21471c-1cad-4781-a3f5-75a150e07208`__: A Suno link to a finished song, created by writing lyrics to the melody of the nonsense song above.

7. __`https://soundcloud.com/marcelous-harris`__: Soundcloud profile.

8. __`https://www.reaper.fm/`__: A link to the website for Reaper, a digital audio workstation (DAW).

9. __`http://emastered.com`__: A link to the website for emastered.com, an online audio mastering service.

The post and comments provide practical advice for improving workflow and getting better results from Suno, focusing on combining creative prompting with an understanding of Suno's strengths and weaknesses. The discussion also touches on music theory and the value of a "performance-first" approach, where the musical performance is prioritized before the lyrics.

---

# CAPTCHAs 10 times a day while using Suno?", along with any external URLs (there are none in this case)

__Summary:__

The original poster (OP) complains about frequently encountering CAPTCHAs (around every 15 songs generated) while using Suno, finding it highly disruptive and annoying. They are posting in the hope that Suno developers will see and address this issue, as it's making them consider canceling their subscription.

The comments reveal a wide range of experiences:

- __Many users report *never* encountering CAPTCHAs:__  A significant number of commenters state they've used Suno extensively (hundreds or even thousands of songs) without ever seeing a CAPTCHA. This suggests the issue is not universal.

- __Possible Triggers:__
  - __Rapid Generation:__ The OP admits to generating songs quickly to use up expiring credits.  This rapid-fire use is identified as a likely trigger, similar to rate-limiting on other AI platforms.  Suno's "10 running jobs at once" feature is acknowledged as a *possibility*, not a recommended practice.
  - __VPN Use:__ Several users suggest that using a VPN can cause CAPTCHA prompts.  Turning off the VPN, or changing its location, is offered as a potential solution.
  - __Simultaneous Logins:__  One user reports experiencing CAPTCHAs only when logged into both the Suno app and website simultaneously.
  - __Email setup:__ A commentor suggests that the users email might be affecting it, advising to not use email forwarding.
  - __Browser:__ It's suggested that using Firefox might be causing more CAPTCHAs

- __Bot Prevention:__  It's generally understood that CAPTCHAs are implemented to prevent bot activity and protect server resources.  While annoying, they are seen as a lesser evil compared to being completely blocked by bot traffic.

- __Staying logged in__: Commentors suggest that by staying logged in using the Google sign-in method, they have never encountered a CAPTCHA

In essence, the thread highlights a discrepancy in user experience.  While the OP is significantly impacted by CAPTCHAs, many others are not.  The consensus leans towards rapid generation and VPN usage as the most likely causes, with the underlying purpose being bot prevention. There is no suggestion that the CAPTCHAs are *intended* for regular users under normal usage patterns.

__External URLs:__ There are no external URLs in this post or the comments.

---

# Guide to Epic Music Creation

__Summary:__

This post is a comprehensive guide written by user "Epoyato" on how to create complex, epic, tribal, or cinematic music using Suno AI, specifically targeting styles similar to the group Two Steps from the Hell. The guide focuses on giving the user a high degree of control over the AI's output.

__Key Sections of the Guide:__

1. __Essential Principles:__
    - __Language:__ All instructions should be in English, except for standard Italian musical terms (Allegro, Presto, Adagio).
    - __Character Limits:__  Style of Music (200 characters), Custom Lyrics (3000 characters).
    - __Main Fields:__  Title, Style of Music, Lyrics, and crucial ending tags (`[Outro: Extended]`, `[End: Fade Out]`).

2. __Structuring the "Style of Music" Field:__  This field defines the genre, instrumentation, atmosphere, and rhythm.  The recommended structure is:
    - Main Genre/Style (e.g., "Epic Orchestral")
    - Primary Instrumentation (e.g., "deep war drums, male choir")
    - Atmosphere/Emotions (e.g., "heroic, solemn")
    - BPM/Rhythm (e.g., "tempo 78 BPM, march-like")
    - Vocal Elements (e.g., "solo contralto female voice")
    - An example is provided, integrating all these elements.

3. __Song Structure and Meta-Tags:__  This section outlines the standard song sections (Pre-Intro, Intro, Verse, Pre-Chorus, Chorus, Bridge, Instrumental Break, Coda, Outro) and provides a *very* specific order for tags within the lyrics:
    - Section > Vocal Type > Dynamics > Vocal Style > Vocal Quality > Instructions > Lyrics
    - A detailed example demonstrates how to combine these elements (e.g., `[Chorus, Full Orchestra, Choir] [Dynamic: ff] [Vocal Style: Male Choir, Deep and Powerful] [Instructions: Build intensity, layered harmonies] Lyrics: > “We march, we rise, we conquer!”`)

4. __Controlling Expressiveness and Mixing:__  This section covers advanced modifiers:
    - __Tempo Modifiers:__ Accelerando, Ritardando, Rubato.
    - __Expression Dynamics:__  Swelling Strings, Sudden Crescendo, Gradual Fade-out.
    - __Micro-Phrasing:__ Subtle variations in articulation.
    - __Stereo Placement:__ Hard Left, Wide Stereo, Centered Vocals.
    - An example shows how to combine these for nuanced control.

5. __Vocal Techniques and Choirs:__  This section expands on vocal control:
    - __Vocal Expressiveness:__ Breath Control (Heavy Breathing, Whispered Breath), Dynamic Choir Sections (Solo Tenor → Full Choir Crescendo), Extended Vocal Techniques (Fry Scream, Throat Singing, Kulning).
    - An example shows how to layer these techniques.

6. __Advanced Use of Effects:__  This section delves into specific sound effects and mixing techniques:
    - __Effect: Reverb:__  Deep Cathedral, Plate, Gated.
    - __Effect: Granular Synthesis:__  For glitchy, atmospheric effects.
    - __Effect: Stereo Panning:__  For creating an immersive experience.
    - __Effect: Exponential Decay Reverb:__  For simulating epic environments.
    - An example demonstrates how to use these effects to create a "mystical, fading effect."

7. __Writing More Natural and Impactful Lyrics:__  The guide recommends avoiding generic words and clichés commonly generated by AI (dreams, heart, soul, etc.) and suggests more unique alternatives (tempest, clan, oath, etc.).

8. __Using Double Asterisks (\*\*) and the ">" Symbol:__
    - __\*\*__:  For emphasis, dramatic pauses, or highlighting key words.
    - __>__:  For introducing choir lines or secondary interjections.
    - __> \*\*__:  For strong choir statements.
    - Examples are provided to illustrate these uses.

__Comments Section Highlights:__

- __ChatGPT Integration:__  A commenter suggests using an LLM (like ChatGPT) to help refine prompts and song structures based on the guide's instructions.
- __Lyric Writing Tips:__  Another commenter recommends focusing on writing what *you* like, rather than worrying about avoiding AI-sounding words.  They also suggest watching songwriter videos on YouTube.
- __Stretching Vocal Lines:__  A user asks about extending vocal parts, and the author provides an example and suggests a possible approach.
- __Bracket vs. Parentheses:__  There's a discussion about the difference between `[]` and `()` in Suno.  The author claims that using `()` can lead to the AI interpreting them as lyrics, and brackets are preferable. Another uses `()` to signify background vocals.
- __Suno's GitHub:__  The author mentions looking at Suno's GitHub repository and other audio AI libraries to find potential commands and capabilities.
- __Double Asterisks and Bleeps:__  A user reports that using `**` resulted in a bleep sound, as if censoring a swear word.
- __"Hallucinated" songs method__:
- __Complexity and Accessibility:__ A comment highlights the complexity of the guide, especially for those with mental health challenges and past negative experiences. The author provides detailed explanations and simple examples to try.
- __Vocaloid Songs__: Using brackets when prompting helps with creating vocaloid songs.

__External URLs (Outside of Reddit):__

1. __`https://suno.com/song/0acdd402-5f52-4ab7-a4ed-a396a8cf1397`__:  An example Suno song demonstrating a stretched vocal line.
2. __`https://suno.com/song/fcf7472a-1a7b-4506-87bf-aa2ef1f0e198`__: An example Suno song ("Runes of Ancients") created using the guide's techniques.
3. __`https://suno.com/song/330fe414-46f0-4c8c-b3e0-bd0d015964d2`__:  Another example Suno song ("Dark House Viking").
4. __`https://suno.com/song/0cbf9be3-e26a-4337-a241-74c438f91a7c`__:  Another example Suno song ("Father of Fenrir").
5. __`https://suno.com/song/0d77cdd9-d49c-44eb-9ac2-c3c6a910e910`__:  Another example Suno song ("March of the Ancient Tribes").
6. __`https://suno.com/song/f142d91e-4f5c-493a-8d2b-33bb660c574d`__:  An example Suno song showcasing experimental use of placeholders.
7. __`https://github.com/suno-ai?utm_source=chatgpt.com`__: The GitHub repository for Suno AI.
8. __`https://youtu.be/xCghv4gQcu0`__: A YouTube link to an "epic tribal war anthem".
9. __`https://suno.com/song/1240f18c-07e7-4554-a230-72c599d24b04`__: An example of a beatbox viking song.

This guide provides a very structured, detailed, and somewhat prescriptive approach to using Suno, aiming for a specific type of musical output. It reflects a deep engagement with the tool and a desire to push its capabilities.

---

# THE SECRET TO CREATING GOOD SUNO MUSIC

__Summary:__

This post and its extensive comments provide a guide to improving the quality of music generated by Suno, focusing on lyric quality, prompt engineering, and song structure. The core advice is to actively craft the lyrics and use detailed prompts rather than relying on Suno's default settings.

__Main Points:__

- __Lyrics are Key:__ The most important aspect is writing "awesome lyrics, stories, hooks, and lyrical conversations." This includes creating a theme or backstory.
- __Structure and [[Prompts]]:__ Use song structure (intro, verse, chorus, etc.) and insert commands within the lyrics section using *double* brackets `[[ ]]`. Examples:
  - `[[Command/prompt]]` for general directions.
  - `[[chop, layer, echo, reverb, attack]]` for drops and builds.
  - `[[Harmonize female vocals]]` at the start of a chorus.
  - `[[call and response]]` for duets.
  - `[[vocal ad-libs]]` for added depth.
  - `[[Beats fade out echo clean]]` for a clean ending.
- __Genre-Specific Advice (EDM):__ For electronic genres like house, EDM, D&B, and future bass, only a few lines of lyrics are needed. Focus on a catchy hook.
- __AI Personas:__ Give the AI singers distinct characteristics (e.g., "soulful uplifting sultry female vocal with husky British voice").
- __Duets:__  Create duets by specifying which voice sings which line (e.g., `[Male]`, `[Female]`).  "Call and response" prompts are suggested.
- __Using 3rd Party AI:__  Use other AI tools (like ChatGPT) to help with song structure.  Refine the AI's initial suggestions to be more soulful, gritty, etc. Then, *humanize* the AI-generated lyrics by changing words, adding slang, etc.  This is a learning process, not just copy-pasting.
- __Learn about Music:__  Understand singing styles, rapping techniques, and lyricism.
- __"HD Quality studio Production":__ Try adding this to the "Style of Music" box.
- __Double Brackets:__ The author insists on using `[[ ]]` instead of `[]` or `()`, claiming the latter two can be misinterpreted as lyrics.
- __BPM Control__: You can specify a tempo by using `[TEMPO:80BPM]`.
- __Drum control__

__Comments Section Highlights:__

- __Ears and Taste:__  Some commenters emphasize that personal taste is the ultimate secret.
- __Duran Duran/Goldfrapp Analogy:__  The original poster uses a concert experience to illustrate the importance of pushing boundaries and creating new musical experiences.
- __Duet Techniques:__ Several users offer detailed advice on creating duets, including specific prompt formats (e.g., `[Verse 1 - Male Voice]`, `[Chorus - Together]`, `[MALE VOICE] (FEMALE VOICE)]`).
- __Bracket Debate:__ There's a debate about whether to use `[]`, `()`, or `[[]]`.  The author is adamant about `[[]]`, but others report different experiences.
- __Example Songs:__ Several users share Suno and Spotify links to demonstrate their results.
- __BPM Control:__  A user suggests using `~133bpm` for approximate tempo control, while another recommends `[TEMPO:80BPM]` for more precision.
- __Vocal Techniques:__ A commenter recommends using "rubato" and "melismatic" for more unique vocal performances.
- __ChatGPT Integration:__  Several users mention using ChatGPT to help with lyrics and song structure.
- __"Shimmer" Issue:__ A user mentions the persistent "shimmer" artifact in Suno's output.

__External URLs (Outside of Reddit):__

1. __`https://suno.com/song/4b92f438-ac28-4710-b4a8-4c9b8fcf388e`__: A Suno link to a song demonstrating a duet.
2. __`https://open.spotify.com/track/2Ompx6uQfyGKYtIIm5Lgz0?si=rVWt8sbiSB2ofpfoTydYvA`__: A Spotify link to another duet example.
3. __`https://suno.com/song/f870afa0-2595-4973-8907-0e28f829f7ec`__:  A Suno link to a song demonstrating the techniques from the original post.
4. __`https://open.spotify.com/album/0CaGBUKyYTeb2jMIhxX0Er?si=bz8wHBrBTlGoJlN0a8MXWg`__: A spotify album, showing the lyrics the commentor wrote.
5. __`https://www.reddit.com/user/CharmingAd2038/comments/1irjoi3/delete_the_elite/?utm_source=share&utm_medium=mweb3x&utm_name=mweb3xcss&utm_term=1&utm_content=share_button`__:  A Reddit post (by the original poster) showcasing a hip-hop track. (This URL appears twice.)

In summary, this post and its comments provide a wealth of practical, though sometimes debated, advice for creating better music with Suno.  The main takeaway is that active involvement in lyric writing and prompt crafting, combined with an understanding of musical concepts, is crucial for getting the best results.

---

# Tips and Tricks

Here's a compilation of the most useful Suno tips and tricks, combining the advice from all three provided Reddit posts and their comment sections. I've organized them by category for clarity.  I'm focusing on actionable advice and excluding things like personal anecdotes or general discussions unless they contain specific, helpful techniques.

__I. Core Songwriting and Lyric Crafting__

- __Write Good Lyrics:__ This is consistently emphasized. Focus on strong hooks, stories, and "lyrical conversations." Don't rely on Suno's default lyric generation for quality.  Write them yourself, or if using AI assistance, heavily edit and personalize the results.
- __Song Structure:__ Use a clear, defined structure (Intro, Verse, Pre-Chorus, Chorus, Bridge, Outro, etc.). Label these sections *within* the lyrics input using brackets.
- __Use ChatGPT for Assistance (with heavy editing):__ Use ChatGPT (or similar LLMs) to help you:
  - Brainstorm song structures.
  - Refine your *own* lyrics (improve word choice, organization, metaphors).
  - Analyze existing songs you like for structure and style.
  - Generate "metatags" or descriptions of how each part of the song should be performed (then heavily adapt these for Suno).
  - *Do not* simply copy and paste AI-generated lyrics without significant editing.  Humanize them with slang, colloquialisms, and your personal style.
- __Metatags in Lyrics__
  - Place metatags before each verse, chorus, intro, outro.
  - Use metatags to indicate specific musical actions or moods in specific parts.

__II. Prompt Engineering and Tagging__

- __Brackets:__ There's disagreement, but the most common advice is:
  - Use `[]` for *most* in-lyric instructions and musical directions.
  - Use `()` for backing vocals or responses in a call-and-response.
  - Some users prefer `[[]]` to prevent Suno from interpreting commands as lyrics. Experiment to see what works best.
- __Lyric Section Commands:__ You can put musical instructions and effects *within* the lyrics section, enclosed in brackets. This gives you more fine-grained control.  Examples:
  - `[Chorus, Full Orchestra, Choir]`
  - `[Dynamic: ff]` (ff = very loud, pp = very soft, see section on dynamics below)
  - `[Vocal Style: Male Choir, Deep and Powerful]`
  - `[Instructions: Build intensity, layered harmonies]`
  - `[Effect: Deep Cathedral Reverb]`
  - `[chop, layer, echo, reverb, attack]` (for drops and builds)
  - `[Scream]` or `[(guttural scream), My veins!]` – Brackets and capitalization.
  - `[laugh in beat "Ha haaaa ha hahaa ha haa"]`
  - `[Instrumental Break]`
  - `[Guitar Solo]`
  - `[Sitar, single sustained note, shimmering with vibrato] (e.g., “…eeeeeennnnnn…”)`.
- __"Style of Music" Field:__  Be specific and structured.  Order matters:
    1. Main Genre/Style (e.g., "Epic Orchestral," "Indie Rock," "Trap")
    2. Primary Instrumentation (e.g., "deep war drums, male choir," "acoustic guitar, synth bass")
    3. Atmosphere/Emotions (e.g., "heroic, solemn," "melancholic, ethereal")
    4. BPM/Rhythm (e.g., "tempo 78 BPM, march-like" or `[TEMPO:80BPM]`)
    5. Vocal Elements (e.g., "solo contralto female voice," "whispered vocals")
- __Specify tempo__: Use a tag like `[TEMPO:120BPM]` in your prompt.
- __Vocal Style Tags:__  Use detailed descriptions for vocals, both in the "Style of Music" field *and* before each verse/chorus in the lyrics.  Examples:
  - `[Smooth Sensual Female Vocal]`
  - `[Male Vocal]`, `[Female Vocal]`
  - `[MALE VOICE] [FEMALE VOICE]`
  - `[Duet with male and female voices blending]`
  - "soulful uplifting sultry female vocal with husky British voice"
  - `[[MALE VOICE] (FEMALE VOICE)]]`
  - `Lyrics here(lyrics here)`
  - "minimal lyrical singing, sparse humming"
- __Exclude Styles:__ Use the "Exclude Styles" feature to prevent unwanted instruments or styles.
- __Avoid Artist Names:__ Instead of directly naming artists, use terms like "Zimmer-core" or "Eminem-inspired."
- __Experiment with Punctuation__: Use punctuation sparingly to add the desired pause to vocals.
  - Commas create short pauses, ellipses create longer pauses.
- __Referencing Musical Styles:__ Use terms like, "Zimmer-core" or "Eminem-inspired".
- __Using Numbers:__ Use numbers instead of writing the numbers.
- __Dual Lyrics:__
  - Add "Layered Vocals"
- __Non-Standard Accents__
  - Write the lyrics in a way that you phonetically want it to sound, using any language that will achieve that sound.
  - Remaster the song
  - Edit the lyrics to the original intended words.
- __Specify BPM__
  - Specify the BPM in the prompt or by using [Tempo: 80BPM]
- __Punctuation:__
  - Use punctuation sparingly
  - Comma = Short Pause
  - Elipses = Longer Pause
  - Quotations = Changes tone
- __Specific musical terms__
  - Add terms such as, BPM, pitch and voice styles to the prompt.
- __"Hallucinated" Songs (Performance-First Workflow):__
    1. Create a song *without* providing lyrics (or with nonsense lyrics).  Let Suno generate both the music *and* a vocal melody.
    2. If you like the generated performance, use the "Replace Section" feature to add your *own* lyrics, fitting them to the existing melody. This prioritizes musical performance over pre-written lyrics.
- __QRNG for Variety:__ Use a quantum random number generator (like `https://qrng.anu.edu.au/random-block-alpha/`) and add a random string to the end of your prompt to introduce more variation.
- __"HD Quality studio Production":__  Try adding this to the "Style of Music" box.
- __Mastering Tags__
  - Add tags such as [professional mastering], [Dolby Atmos mix], [high-fidelity], [high-definition audio], [wide stereo] to the lyrics box at the beginning of each song.

__III. Song Structure and Flow__

- __Standard Sections:__ Use tags like `[Intro]`, `[Verse]`, `[Pre-Chorus]`, `[Chorus]`, `[Bridge]`, `[Outro]`.
- __Ending the Song:__  *Always* include `[Outro: Extended]` and `[End: Fade Out]` (or similar) to prevent abrupt endings.  This is crucial.
- __False Outro:__ Create a "false outro" by ending a section prematurely and then extending it, creating a climax.
- __Repeating Sections:__
  - If your song is repeating sections, try deleting [Verse] tags.

__IV. Vocal Techniques and Effects__

- __Duets:__
  - Specify "Duet" in the style.
  - Use `[Male]` and `[Female]` tags before each line or section to indicate who should sing.
  - Use `[Chorus - Together]` for both voices.
  - Use "call and response" prompts.
- __Ad-libs:__ Use `( )` or `[[vocal ad-libs]]`.
- __Runs and Melisma:__ Use "melismatic" or spell out runs phonetically.
- __Vocal Expressiveness:__ Use terms like:
  - "rubato" (flexible tempo)
  - "heavy breathing," "whispered breath"
  - "fry scream," "throat singing" (for specific styles)
  - "vibrato"
- __Humming/Minimal Vocals:__
  - In style: "minimal lyrical singing, sparse humming"
  - In lyrics: "[intro: no singing]", "[verse: sparse hums](hum, hum, hummmmmmm)" etc.
- __Dynamics:__ Use Italian terms (or their abbreviations) within brackets:
  - `pp` (pianissimo - very soft)
  - `p` (piano - soft)
  - `mp` (mezzo-piano)
  - `mf` (mezzo forte - moderately loud)
  - `f` (forte - loud)
  - `ff` (fortissimo - very loud)
  - `fff` (fortissimo)
  - `ffff` (fortississimo - very loud)
  - `crescendo` (gradually getting louder) - can be written as `>>>`
  - `decrescendo` or `diminuendo` (gradually getting softer) - can be written as `<<<`
  - `[Dynamic: pp to ff]` (gradual increase from very soft to very loud)
  - "sforzando" (sudden, strong accent)
  - "morendo" (fading away into silence)
- __Tempo Modifiers:__ `[Accelerando]` (speeding up), `[Ritardando]` (slowing down).
- __Stereo Placement:__ `[Stereo Placement: Whispered Vocals Hard Left, Strings Wide Stereo]`
- __Effects:__
  - `[Effect: Reverb] (Deep Cathedral, Plate, Gated)`
  - `[Effect: Granular Synthesis]` (for glitchy effects)
  - `[Effect: Stereo Panning]`
  - `[Effect: Exponential Decay Reverb]`
- __Sound Effects__
  - Use brackets [] and put the desired sound effect in the lyrics section

__V.  Working with Other Tools__

- __ChatGPT (and other LLMs):__  Essential for many advanced techniques.  Use it for:
  - Lyric generation and refinement.
  - Prompt formatting.
  - Exploring song styles and structures.
  - Analyzing existing songs.
- __DAWs (Digital Audio Workstations):__  Recommended for post-processing (Audacity is a free option, FL Studio, Reaper, and others are mentioned).  Use them for:
  - Stem separation (isolating vocals and instruments).  (Ultimate Vocal Remover, Open Vino Music Separation Plugin, Serato Studio, and djay Pro are also mentioned).
  - EQ adjustments (see next section).
  - Adding fade-outs.
  - Mixing and mastering.
- __Cyanite.ai, Sonoteller.ai, Music.ai:__ Use these to analyze existing songs and get metadata to inform your Suno prompts.
- __NeuralFrames:__ Use this for creating music videos.
- __Converting to Mono:__ Before doing extensive editing, it's often recommended to convert the Suno output to mono (using a tool like `https://onlineaudioconverter.com/`) to fix panning issues, then re-introduce stereo width later.

__VI.  Troubleshooting and Fixing Audio Issues (Post-Processing)__

These tips generally require using a DAW or audio editor.

- __Buried/Overpowered Vocals:__
  - Reduce low-mid frequencies (200-500Hz) in the instruments.
  - Boost upper-mid frequencies (2kHz-5kHz) in the vocals.
  - Apply gentle stereo widening to the vocals.
- __Hard-Panned Instruments:__
  - Convert to mono, then re-introduce stereo width.
  - Manually adjust panning.
- __Harsh Highs:__
  - Reduce high frequencies (8kHz-12kHz).
  - Apply de-essing to smooth out sibilance ("s" and "t" sounds).
- __Muffled/Muddy Sound:__
  - Cut low-mid frequencies (200-400Hz).
  - Boost upper-mid frequencies (2kHz-5kHz).
- __Random Distorted Sounds (AI Artifacts):__
  - Try regenerating the song.
  - Cut harsh frequencies (3kHz-5kHz).
  - Use noise reduction tools.
- __Bass Issues:__
  - If weak: Boost low frequencies (60-100Hz).
  - If overpowering: Reduce sub-bass (below 50Hz).
- __"Shimmering"__
  - Cut out the 12k range, in the stem where the shimmering sound is.
  - Apply De-Esser
- __Flat/Lifeless Mix:__
  - Reduce compression.
  - Slightly boost upper-mid frequencies (2kHz-5kHz).
  - Use transient enhancement.
- __Sudden Volume Dropouts:__
  - Split the track into stems and fix the missing parts.
  - Adjust EQ.
  - If severe, regenerate.
- __Abrupt Fade-Outs:__
  - Manually add a fade-out in your editor.
- __Download Issues:__
  - Disable VPN
- __Get Whole Song:__
- Find the song you want to use commercially that was made using a free account
- Click extend
- Change the extend time, removing the last two seconds
- Regenerate the last two seconds
- Click get whole song
- __Getting Back Lost Lyrics__
  - Extend song from a starting point prior to the wrong words
  - Add the correct lyrics in the extension section

__VII. General Workflow and Best Practices__

- __v3.5 vs. v4:__ Generate the full song in v3.5 (better structure, instrumentals) and then *remaster* it in v4 (better vocals).
- __Always Extend from the Full Song:__  When using the "Extend" feature, start from the complete song, not a partial section.
- __Download as WAV:__  Always download in WAV format for the highest quality.
- __Iterative Process:__  Experiment, listen critically, and be prepared to regenerate and refine your songs multiple times.
- __Test on Multiple Devices:__ Check how your song sounds on different playback systems.

This comprehensive list covers the vast majority of actionable tips and tricks found within these three Reddit threads.  It provides a detailed roadmap for users who want to significantly improve their Suno creations, from initial prompt crafting to final audio polishing. Remember to experiment, have fun and that this is a process of continous learning.

---

================================================
File: trimr.py
================================================

import os
from pydub import AudioSegment

def detect_leading_silence(sound, silence_threshold=-50.0, chunk_size=10):
    """
    Detects silence at the beginning of an audio segment.

    :param sound: The audio segment to analyze.
    :param silence_threshold: The dBFS value below which sound is considered silence.
    :param chunk_size: The size of each chunk to analyze in milliseconds.
    :return: The duration of the leading silence in milliseconds.
    """
    trim_ms = 0  # Duration of silence in milliseconds

    assert chunk_size > 0  # Prevent infinite loop
    while trim_ms < len(sound):
        chunk = sound[trim_ms:trim_ms + chunk_size]
        if chunk.dBFS >= silence_threshold:
            break
        trim_ms += chunk_size

    return trim_ms

# Directory containing your MP3 files

directory = r"C:\Users\whois\OneDrive\The Casket Diaries Soundtrack\Main Theme"

# Parameters for silence detection

silence_threshold = -50.0  # Adjust this value if needed
chunk_size = 10            # Size of each chunk in milliseconds

for filename in os.listdir(directory):
    if filename.lower().endswith(".mp3"):
        file_path = os.path.join(directory, filename)
        print(f"Processing: {file_path}")

        # Load the audio file
        audio = AudioSegment.from_mp3(file_path)

        # Reverse the audio to detect silence at the end
        reversed_audio = audio.reverse()

        # Detect leading silence in the reversed audio (which is trailing silence in the original)
        trim_ms = detect_leading_silence(
            reversed_audio,
            silence_threshold=silence_threshold,
            chunk_size=chunk_size
        )

        # Calculate the new duration
        new_duration = len(audio) - trim_ms
        trimmed_audio = audio[:new_duration]

        # Export the trimmed audio back to the same file
        trimmed_audio.export(file_path, format="mp3")
        print(f"Trimmed {trim_ms} ms of silence from the end of {filename}.")

print("All files have been processed.")

================================================
File: uniq.py
================================================

def process_urls(input_file, output_file):
    with open(input_file, 'r') as infile:
        content = infile.read()

    # Split the content by commas to get individual URLs
    urls = content.split(',')

    # Remove duplicates by converting the list to a set, then back to a list
    unique_urls = list(set(urls))

    # Remove any empty strings that may result from trailing commas
    unique_urls = [url for url in unique_urls if url]

    # Join the unique URLs with a space
    result = ' '.join(unique_urls)

    # Write the result to the output file
    with open(output_file, 'w') as outfile:
        outfile.write(result)

if __name__ == "__main__":
    input_file = 'songs.txt'
    output_file = 'unique_songs.txt'
    process_urls(input_file, output_file)
    print(f"Unique URLs have been written to {output_file}")

================================================
File: unique_songs.txt
================================================
<https://suno.com/song/27ae843d-c3eb-44ed-b1e8-5b93e236a2d8>

================================================
File: url.txt
================================================
<https://suno.com/song/12bfb381-df41-4452-9846-399e5e70153d> <https://suno.com/song/9a343031-83c3-4d9e-82d5-05fb5975c5c1> <https://suno.com/song/f8e26fd7-00c0-4ced-b121-211301191d28> <https://suno.com/song/146f1ff0-94a0-40a5-82cc-242ca3a1afd8> <https://suno.com/song/ca51c0e1-fd9f-495e-84d1-c9f48fea8a49> <https://suno.com/song/246cd95f-0587-4e80-97a0-8a5a2a5858b0> <https://suno.com/song/cc9edc17-2eb7-486a-a11d-a975e02b6b29> <https://suno.com/song/04bf3a90-fa72-470b-bc3b-11caf5487744> <https://suno.com/song/fd0f50c6-2d44-4012-b3cd-9e6bf6793211> <https://suno.com/song/42c23019-e2cd-4562-a736-f55f23a8f980> <https://suno.com/song/8c0024d0-1138-456a-b4f2-52ff123df24c> <https://suno.com/song/bf3629a2-a294-4247-9e60-4d3f773b877a> <https://suno.com/song/a2bdf1f4-90fd-4001-a6f3-3f54515462ee> <https://suno.com/song/04297282-e855-45c0-af32-6718cbb56965> <https://suno.com/song/caef121d-e539-4fd3-b02a-aaf50dac8c85> <https://suno.com/song/85202ef8-3f98-4e50-bb25-2e2c30bac2af> <https://suno.com/song/76c920ef-f81e-4f24-a562-ec1ebfcea061> <https://suno.com/song/8818fb39-7930-43b0-bbd4-22d3cf89730f> <https://suno.com/song/9a93f5fb-78af-4736-9213-bfb53f462a29> <https://suno.com/song/e99857b0-b971-4123-b144-a02fc779bae5> <https://suno.com/song/17217b39-8dfd-40d2-9996-07d26b879b60> <https://suno.com/song/71f2c817-f21c-4ea9-b7ac-7c57f662741f> <https://suno.com/song/3f75ea89-bd89-4518-b5d5-c8da3c038e4d> <https://suno.com/song/f769dfa7-c583-4cda-a583-ab0cb263070f> <https://suno.com/song/a412d81d-d81c-41a1-bd01-757790a397a4> <https://suno.com/song/435bef03-0ccf-4aa2-94d3-1bf7cc9ad12d> <https://suno.com/song/be31b123-a814-427f-bd4c-82db5b5e1370> <https://suno.com/song/e2fbdc9d-e470-430a-91b6-75cebb761f73> <https://suno.com/song/ce793bbe-410e-4374-bbe8-26f4d3efcd86> <https://suno.com/song/738575d2-83b4-4a99-b8b4-515d6522d3a8> <https://suno.com/song/ee02d8a0-6ecb-423c-afef-2fb2c25242db> <https://suno.com/song/d48017b1-9ec2-4612-af2c-8a507d38c2ad> <https://suno.com/song/f67d6257-c4ab-40cb-99a3-539c6ebd7ab0> <https://suno.com/song/7a596577-6320-44a6-8c70-a1b831d977ef> <https://suno.com/song/1f4d621e-873f-41f1-bb69-f0f25b82d89c> <https://suno.com/song/1ee52a52-c6d3-4182-8444-12b6dfe9f085> <https://suno.com/song/4817a365-0ab3-4af7-8cba-248f52bcc067> <https://suno.com/song/60ae1fa1-5719-4346-8f06-0ee0841b6b12> <https://suno.com/song/b8d3bcf9-5194-4030-9560-4bc88c27a428> <https://suno.com/song/61278c33-8a68-43c9-8160-1d8d673a1374> <https://suno.com/song/64b02d87-daa4-44a5-b34a-605e55b8d321> <https://suno.com/song/cc32f76a-311a-4b8e-ba7f-55d4cec86349> <https://suno.com/song/ce647d27-a9a8-46dd-b415-3ddece28158a> <https://suno.com/song/c98a2801-9cdd-42d8-9aa9-cd2517392758> <https://suno.com/song/c5bd7ba3-9a69-4cca-b832-20c3ae44eacf> <https://suno.com/song/950faef8-a7f8-4062-8995-7efd88332b14> <https://suno.com/song/e65ade1a-4b9c-44cb-993a-4c53f8864ed3> <https://suno.com/song/3dba701e-01af-4165-927a-1669a22556b7> <https://suno.com/song/51dfa874-8671-49ae-a3ee-888da8f46c30> <https://suno.com/song/c64c9e6f-6510-42b5-8020-3862bece3613>

================================================
File: DL1/README.md
================================================

# Suno Music Downloader

A set of tools to download your music from Suno.ai with organized filenames and prompts.

## Setup

1. Clone this repository
2. Install Python requirements:

   ```bash
   pip3 install -r requirements.txt
   ```

## Usage

### 1. Get Song Data

1. Login to <https://suno.com/me>
2. Open browser developer tools (F12)
3. Copy and paste the contents of `getData.js` into the console
4. Copy the output and save it to `songs.csv`

The script will generate a CSV with:

- Formatted filenames (with random ID)
- Download URLs
- Original prompts and UUIDs

### 2. Download Songs

Run the Python downloader:

```bash
python3 suno-downloader.py
```

### Features

- __Fast Parallel Downloads__: Downloads 4 files simultaneously
- __Smart File Handling__:
  - Skips existing files automatically
  - Creates organized filenames with IDs
  - Preserves original UUIDs in text files
- __Progress Tracking__:
  - Real-time progress bars for each download
  - Download speed and size information
  - Completion summary with success/failure counts
- __Error Handling__:
  - Automatic retry on failed downloads (up to 3 attempts)
  - Detailed error reporting
  - Graceful handling of network issues

## Output Structure

```
songs/
  ├── song-name-id-xxxxx.mp3  # Organized filename with random ID
  └── song-name-id-xxxxx.txt  # Matching text file with prompt
```

Text files contain:

```
Original filename: uuid.mp3

Prompt:
Your original generation prompt
```

## Files

- `getData.js` - Browser script to extract song data
- `suno-downloader.py` - Python script with parallel download capability
- `requirements.txt` - Python package dependencies
- `songs.csv` - Generated list of songs to download

## Technical Details

- Uses Python's ThreadPoolExecutor for parallel downloads
- Configurable number of simultaneous downloads (default: 4)
- Progress bars powered by tqdm
- Robust error handling with automatic retries

================================================
File: DL1/getData.js
================================================

// Login to <https://suno.com/me>
copy(
  [
    "song_name,song_url,song_prompt",
    ...[
      ...$('[role="grid"]')[
        Object.keys($('[role="grid"]')).filter((x) =>
          x.startsWith("__reactProps")
        )[0]
      ].children[0].props.values[0][1].collection,
    ]
      .filter((x) => x.value.audio_url)
      .map((x) => {
        const title = x.value.title.trim() || x.value.id;
        // Use a hash of the song's ID for consistency
        const hash = x.value.id.slice(0, 5); // Use the first 5 characters of the ID
        // Get UUID from the song's ID
        const uuid = x.value.id;
        // Format filename: lowercase, replace spaces with dashes, add id and hash
        const formattedTitle = `${title
          .toLowerCase()
          .replace(/\s+/g, "-")}-id-${hash}`;

        // Find the description from the DOM using the song ID
        const songElement = document.querySelector(
          `[data-clip-id="${x.value.id}"]`
        );
        let description = "";
        if (songElement) {
          const descriptionSpan = Array.from(
            songElement.querySelectorAll("span[title]")
          ).find((span) => span.textContent.trim().length > 50);
          description = descriptionSpan
            ? descriptionSpan.getAttribute("title").trim()
            : "No description available";
        }

        // Include original UUID filename in the description
        const fullDescription = `Original filename: ${uuid}.mp3\n\nPrompt:\n${description}`;

        // Always wrap description in quotes for consistency, and ensure no trailing newline
        return `${formattedTitle}.mp3,${
          x.value.audio_url
        },"${fullDescription.replace(/\n$/, "")}"`;
      }),
  ]
    .join("\n")
    .trim() // Trim any extra whitespace/newlines from the final output
);

================================================
File: DL1/requirements.txt
================================================

tqdm>=4.65.0
requests>=2.31.0

================================================
File: DL1/suno-downloader.py
================================================

# !/usr/bin/env python3

import csv
import os
import time
from concurrent.futures import ThreadPoolExecutor
from tqdm import tqdm
import requests
from pathlib import Path
import sys

MAX_RETRIES = 3
MAX_WORKERS = 4

def download_file(url, filename, total_size=None):
    """Download a file with progress bar and retry logic."""
    for attempt in range(MAX_RETRIES):
        try:
            response = requests.get(url, stream=True)
            response.raise_for_status()

            total = total_size or int(response.headers.get("content-length", 0))

            with open(filename, "wb") as f, tqdm(
                desc=Path(filename).name,
                total=total,
                unit="iB",
                unit_scale=True,
                unit_divisor=1024,
            ) as pbar:
                for data in response.iter_content(chunk_size=1024):
                    size = f.write(data)
                    pbar.update(size)
            return True

        except Exception as e:
            if attempt < MAX_RETRIES - 1:
                print(f"\nRetrying {filename} (Attempt {attempt + 2}/{MAX_RETRIES})")
                time.sleep(2)
            else:
                print(f"\nFailed to download {filename}: {str(e)}")
                return False

def process_song(row):
    """Process a single song (for parallel processing)."""
    try:
        # Skip empty or malformed rows
        if not row or len(row) != 3:
            print(f"Skipping invalid row: {row}")
            return False

        filename, url, description = row

        # Skip if any required field is empty
        if not all([filename.strip(), url.strip(), description.strip()]):
            print(f"Skipping row with empty fields: {filename}")
            return False

        # Create full paths
        mp3_path = os.path.join("songs", filename)
        txt_path = os.path.join("songs", filename.replace(".mp3", ".txt"))

        # Skip if files already exist
        if os.path.exists(mp3_path) and os.path.exists(txt_path):
            print(f"Skipping existing file: {filename}")
            return True

        # Save description to text file
        with open(txt_path, "w", encoding="utf-8") as txt_file:
            txt_file.write(description.strip())

        # Download MP3
        return download_file(url, mp3_path)
    except Exception as e:
        print(
            f"Error processing song {filename if 'filename' in locals() else 'unknown'}: {str(e)}"
        )
        return False

def main():
    """Main execution function."""
    # Create songs directory if it doesn't exist
    os.makedirs("songs", exist_ok=True)

    # Read the CSV file
    try:
        with open("songs.csv", "r", encoding="utf-8") as file:
            # Use csv.reader with proper quoting and filtering
            reader = csv.reader(file, quoting=csv.QUOTE_ALL, skipinitialspace=True)
            next(reader)  # Skip header
            # Filter out empty rows and validate row length
            songs = [row for row in reader if row and len(row) == 3]
    except FileNotFoundError:
        print("Error: songs.csv not found")
        sys.exit(1)
    except Exception as e:
        print(f"Error reading CSV: {str(e)}")
        sys.exit(1)

    if not songs:
        print("No valid songs found in CSV")
        sys.exit(1)

    print(f"Found {len(songs)} valid songs to process")

    # Process songs in parallel
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        results = list(executor.map(process_song, songs))

    # Summary
    successful = sum(1 for r in results if r is True)
    print(f"\nDownload complete!")
    print(f"Successfully downloaded: {successful}/{len(songs)} songs")
    if successful != len(songs):
        print(f"Failed downloads: {len(songs) - successful}")

if __name__ == "__main__":
    main()

================================================
File: DL2/README.md
================================================

# download_suno

## Description

This project automates the processing of [Suno AI](https://suno.com/) MP3 files, including downloading songs, checking for and embedding album artwork, and retrieving metadata. Users can interact with the system via a menu interface to perform operations such as embedding artwork, viewing metadata, and downloading tracks or collections from provided URLs.

### Key Features

- __Download Management__: Download individual songs, playlists, or artist collections from URLs.
- __Artwork Handling__: Check for embedded album artwork in MP3 files and embed artwork from local JPG files.
- __Metadata Extraction__: Extract and display metadata from MP3 files, including song title, artist, and album art presence.
- __Log Management__: View and clear logs of processed songs.

### Technologies Used

- __Python__ for scripting and logic control.
- __Mutagen__ library for MP3 metadata and artwork handling.
- __OS Library__ for directory navigation and file manipulation.

### Installation Instructions

1. Clone the repository:

   ```bash
   git clone https://github.com/skyler-saville/download_suno
   cd <repository-directory>
   ```

2. Install dependencies:

   ```bash
   pip install -r requirements.txt
   ```

3. Ensure you have the necessary directory structure with a `downloads` folder where MP3 files will be processed.

### Usage Instructions

1. Run the main script to interact with the project:

   ```bash
   make run
   ```

2. Use the following options from the menu:
   - `1` to check for embedded artwork in MP3 files.
   - `2` to embed artwork from corresponding JPG files.
   - `3` to extract and display metadata from MP3 files.
   - `5-7` for downloading a song, playlist, or artist collection via URL input.
   - `4` to view the log of processed songs.
   - `8` to clear the log.
   - `0` to exit the application.

### Code Overview

1. __Main Script (`main.py`)__: Handles user interaction through a menu and allows the user to download songs, check metadata, and embed artwork.
2. __Metadata Processing (`get_metadata.py`)__: Extracts metadata such as song ID, title, artist, and album art presence from MP3 files. It also formats song length in mm:ss format.
3. __Artwork Check (`check_artwork.py`)__: Recursively checks for embedded artwork in MP3 files.
4. __Embed Artwork (`embed_artwork.py`)__: Embeds artwork into MP3 files from corresponding local image files (JPG format).

### Contributing

1. Fork the repository.
2. Create a new branch for your feature or bugfix:

   ```bash
   git checkout -b feature/your-feature
   ```

3. Make your changes and commit them:

   ```bash
   git commit -m "Add some feature"
   ```

4. Push to the branch:

   ```bash
   git push origin feature/your-feature
   ```

5. Open a pull request for review.

### License

This project is licensed under the MIT License. See the [LICENSE](./LICENSE) file in the root directory for more details.

---

================================================
File: DL2/check_artwork.py
================================================

import os
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, APIC

def check_embedded_artwork(mp3_file):
    """Checks if there is embedded artwork in the specified MP3 file."""
    try:
        audio = MP3(mp3_file, ID3=ID3)
        if audio.tags:
            for tag in audio.tags.values():
                if isinstance(tag, APIC):
                    print(f"Artwork found in {mp3_file}: {tag.mime}, Description: {tag.desc}")
                    return True
        print(f"No artwork found in {mp3_file}.")
        return False
    except Exception as e:
        print(f"Error reading {mp3_file}: {e}")
        return False

def process_directory(downloads_dir):
    """Recursively processes the downloads directory to check for embedded artwork."""
    for root, _, files in os.walk(downloads_dir):
        for file in files:
            if file.endswith('.mp3'):
                mp3_file_path = os.path.join(root, file)
                check_embedded_artwork(mp3_file_path)

if __name__ == "__main__":
    downloads_dir = './downloads'  # Change this to your downloads directory if needed
    process_directory(downloads_dir)

================================================
File: DL2/embed_artwork.py
================================================

import os
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, APIC

def embed_artwork(mp3_file, image_file):
    """Embeds artwork into the specified MP3 file."""
    audio = MP3(mp3_file, ID3=ID3)

    # Read the image file
    with open(image_file, 'rb') as img:
        image_data = img.read()

    # Create an APIC tag for the artwork
    audio.tags.add(APIC(
        encoding=3,  # 3 is for ID3v2.3
        mime='image/jpeg',  # Change to 'image/png' if the image is a PNG
        type=3,  # 3 is for front cover
        desc='Cover',
        data=image_data
    ))

    # Save changes to the MP3 file
    audio.save()
    print(f"Artwork embedded in {mp3_file}")

def process_directory(downloads_dir):
    """Recursively processes the downloads directory for MP3 files and corresponding artwork."""
    for root, _, files in os.walk(downloads_dir):  # Recursively walk through the directory
        for file in files:
            if file.endswith('.mp3'):  # Check for MP3 files
                mp3_file_path = os.path.join(root, file)
                # Construct the expected JPG file path
                jpg_file_path = os.path.splitext[mp3_file_path](0) + '.jpg'
                if os.path.exists(jpg_file_path):
                    embed_artwork(mp3_file_path, jpg_file_path)  # Embed artwork
                else:
                    print(f"No artwork found for {mp3_file_path}")

if __name__ == "__main__":
    downloads_dir = './downloads'  # Change this to your downloads directory if needed
    process_directory(downloads_dir)  # Start processing the directory

================================================
File: DL2/get_metadata.py
================================================

import os
import re
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, TIT2, TPE1, TXXX, APIC

def format_length(seconds):
    """Convert seconds to mm:ss format."""
    minutes = int(seconds // 60)
    seconds = int(seconds % 60)
    return f"{minutes:02}:{seconds:02}"

def print_metadata(file_path):
    metadata = {}  # Initialize metadata dictionary
    try:
        audio = MP3(file_path, ID3=ID3)

        # Get the song ID
        song_id = audio.get('TXXX:Song ID', None)
        metadata['Song ID'] = song_id.text[0] if song_id else 'Not available'

        # Check for corresponding JPG file
        jpg_file_path = os.path.splitext(file_path)[0] + '.jpg'
        if os.path.exists(jpg_file_path):
            metadata['Album Art'] = jpg_file_path
        else:
            # Check for album art in the tags
            album_art = 'Not available'
            if audio.tags:
                for tag in audio.tags.values():
                    if isinstance(tag, APIC):
                        album_art = 'Embedded art found'
                        break
            metadata['Album Art'] = album_art

        title = audio.tags.get('TIT2')
        artist = audio.tags.get('TPE1')
        upload_date = audio.tags.get('TXXX:Upload Date')  # Retrieve upload date
        length = audio.info.length
        bitrate = audio.info.bitrate

        print("Metadata for:", file_path)
        print("Song ID:", metadata['Song ID'])
        print("Title:", title.text[0] if title else "N/A")
        print("Artist:", artist.text[0] if artist else "N/A")
        print("Upload Date:", upload_date.text[0] if upload_date else "N/A")  # Display upload date
        print("Length:", format_length(length))
        print("Bitrate: {} kbps".format(bitrate // 1000))
        print("Artwork:", metadata['Album Art'])  # Print the final result for Album Art

    except Exception as e:
        print(f"Error reading metadata for {file_path}: {e}")

def list_mp3_files(downloads_dir):
    """List all MP3 files in the downloads directory."""
    mp3_files = []
    for root, _, files in os.walk(downloads_dir):
        for file in files:
            if file.endswith('.mp3'):
                mp3_files.append(os.path.join(root, file))
    return mp3_files

def process_directory(downloads_dir):
    """Process all MP3 files in the downloads directory."""
    mp3_files = list_mp3_files(downloads_dir)

    if not mp3_files:
        print("No MP3 files found in the downloads directory.")
    else:
        for file_path in mp3_files:
            print_metadata(file_path)

if __name__ == "__main__":
    downloads_dir = './downloads'
    # List MP3 files and process them
    process_directory(downloads_dir)

================================================
File: DL2/get_suno.py
================================================

# get_suno.py

import asyncio
from pyppeteer import launch
import argparse
import re
import os
import requests
import datetime
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, ID3NoHeaderError, TIT2, TALB, TPE1, TXXX, APIC
from datetime import datetime
from tqdm import tqdm

def extract_song_id(url): # Moved to utils/url_utils.py
    """Extract the song ID from the URL."""
    match = re.search(r'song/([a-f0-9\-]+)', url)
    return match.group(1) if match else None

# def is_valid_url(url): # Moved to utils/url_utils.py

# print("Checking valid URL in get_suno.py")

# pattern = r'^https?://suno\.com/[song|playlist|@](a-f0-9\-)+/?$'

# is_valid = re.match(pattern, url) is not None

# print(f"Validating URL: {url} | Is valid: {is_valid}")  # Debugging output

# return is_valid

def is_valid_url(url):
    # Example check - you might want to adjust this based on your criteria
    return url.startswith("<https://suno.com/>")

async def fetch_song_data(url):
    try:
        browser = await launch(headless=True)
        page = await browser.newPage()
        await page.goto(url, {'waitUntil': 'networkidle2'})

        # Get the full title
        full_title = await page.evaluate('document.title')
        # Split the title to get the song title and artist
        title, artist = full_title.split(' by @')
        artist = artist.split(' |')[0]  # Get the artist name before the separator

        audio_url = await page.evaluate('''
            () => {
                const metaTags = document.getElementsByTagName('meta');
                for (let tag of metaTags) {
                    if (tag.getAttribute('property') === 'og:audio') {
                        return tag.getAttribute('content');
                    }
                }
                return null;
            }
        ''')

        upload_date = await scrape_upload_date(page)
        album_art_url = await scrape_album_art(page)

        # Return the processed values
        return title.strip(), artist.strip(), upload_date, album_art_url
    except Exception as e:
        print(f"Error fetching data for {url}: {e}")
        return None, None, None, None
    finally:
        await browser.close()

async def scrape_upload_date(page): # Moved to suno/fetch.py
    upload_date_str = await page.evaluate('''
        () => {
            const dateSpan = document.querySelector('.items-center.mt-6 span[title]');
            return dateSpan ? dateSpan.getAttribute('title') : null;
        }
    ''')

    # Normalize the date format
    if upload_date_str:
        try:
            # Parse the date string
            upload_date = datetime.strptime(upload_date_str, '%B %d, %Y at %I:%M %p')
            # Convert to ISO 8601 format
            return upload_date.isoformat()
        except ValueError:
            print(f"Error parsing date: {upload_date_str}")
            return None

    return None

async def scrape_album_art(page): # Moved to suno/fetch.py
    album_art_url = await page.evaluate('''
        () => {
            const metaTags = document.getElementsByTagName('meta');
            for (let tag of metaTags) {
                if (tag.getAttribute('property') === 'og:image') {
                    return tag.getAttribute('content');
                }
            }
            return null;
        }
    ''')
    return album_art_url

def extract_artist_and_title(title): # Moved to utils/metadata_utils.py
    match = re.search(r'^(.*?) by @(.*?)\s*[\|\-]', title)
    if match:
        song_title = match.group(1).strip().replace(' ', '_')  # Sanitize title
        artist = match.group(2).strip()
        return song_title, artist
    return None, None

def sanitize_filename(title): # Moved to utils/file_utils.py
    return re.sub(r'[<>:"/\\|?*]', '', title).strip()

def ensure_directories_exist(artist): # Moved to utils/file_utils.py
    downloads_dir = './downloads'
    if not os.path.exists(downloads_dir):
        os.makedirs(downloads_dir)

    artist_dir = os.path.join(downloads_dir, artist)
    if not os.path.exists(artist_dir):
        os.makedirs(artist_dir)

def download_album_art(album_art_url, artist, title): # Moved to utils/file_utils.py
    if not album_art_url:
        return None

    ensure_directories_exist(artist)  # Ensure directories exist before downloading

    try:
        response = requests.get(album_art_url, stream=True)
        response.raise_for_status()

        # Save the album art in the artist's directory
        art_filename = sanitize_filename(title) + '.jpg'
        art_path = os.path.join('./downloads', artist, art_filename)

        # Use tqdm for progress bar
        total_size = int(response.headers.get('content-length', 0))
        with open(art_path, 'wb') as art_file, tqdm(
            desc=art_filename,
            total=total_size,
            unit='B',
            unit_scale=True,
            unit_divisor=1024,
        ) as bar:
            for data in response.iter_content(chunk_size=1024):
                art_file.write(data)
                bar.update(len(data))

        return art_path
    except Exception as e:
        print(f"Failed to download album art: {e}")
        return None

def download_song(mp3_url, artist, title, upload_date, album_art_path, song_id): # Moved to utils/file_utils.py
    ensure_directories_exist(artist)  # Ensure directories exist before downloading

    sanitized_title = sanitize_filename(title)
    file_path = os.path.join('./downloads', artist, f'{sanitized_title}.mp3')

    if os.path.exists(file_path):
        return False, f'Skipped download. File already exists: {file_path}'

    try:
        response = requests.get(mp3_url, stream=True)
        response.raise_for_status()

        # Use tqdm for progress bar
        total_size = int(response.headers.get('content-length', 0))
        with open(file_path, 'wb') as file, tqdm(
            desc=sanitized_title,
            total=total_size,
            unit='B',
            unit_scale=True,
            unit_divisor=1024,
        ) as bar:
            for data in response.iter_content(chunk_size=1024):
                file.write(data)
                bar.update(len(data))

        # Set metadata using Mutagen
        audio = MP3(file_path, ID3=ID3)  # Use existing ID3 header if available
        audio.tags = ID3()  # Create ID3 tags if they don't exist
        audio.tags.add(TIT2(encoding=3, text=title))  # Title
        audio.tags.add(TPE1(encoding=3, text=artist))  # Artist
        audio.tags.add(TALB(encoding=3, text=''))  # Album
        audio.tags.add(TXXX(encoding=3, desc='Upload Date', text=upload_date))  # Upload Date
        audio.tags.add(TXXX(encoding=3, desc='Song ID', text=song_id))  # Song ID

        # Add album art if available
        if album_art_path:
            with open(album_art_path, 'rb') as img_file:
                img_data = img_file.read()
                audio.tags.add(APIC(
                    encoding=3,
                    mime='image/jpeg',
                    type=3,
                    desc='Cover',
                    data=img_data
                ))

        audio.save()  # Save the changes
        return True, f'Downloaded and tagged: {file_path}'
    except requests.exceptions.HTTPError as http_err:
        return False, f'HTTP error occurred: {http_err}'
    except Exception as err:
        return False, f'Other error occurred: {err}'

def log_song_data(title, artist, audio_url, upload_date, status, reason=""): # MOved to utils/metadata_utils.py
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if status == "Failure" and reason:
        log_entry = f"{timestamp} | Title: {title} | Artist: {artist} | Audio URL: {audio_url} | Upload Date: {upload_date} | Status: {status} | Reason: {reason}\n"
    else:
        log_entry = f"{timestamp} | Title: {title} | Artist: {artist} | Audio URL: {audio_url} | Upload Date: {upload_date} | Status: {status}\n"

    with open("song_data.txt", "a") as f:
        f.write(log_entry)

def process_urls(urls): # Moved to suno/processing.py
    loop = asyncio.get_event_loop()
    for url in urls:
        title, audio_url, upload_date, album_art_url = loop.run_until_complete(fetch_song_data(url))

        if title and audio_url:
            song_title, artist = extract_artist_and_title(title)
            song_id = extract_song_id(url)  # Extract the song ID
            print(f"Title: {song_title}")
            print(f"Artist: {artist}")
            print(f"Audio URL: {audio_url}")
            print(f"Upload Date: {upload_date}")

            # Download the album art
            album_art_path = download_album_art(album_art_url, artist, song_title)

            success, message = download_song(audio_url, artist, song_title, upload_date, album_art_path, song_id)
            print(message)
            if success:
                log_song_data(song_title, artist, audio_url, upload_date, "Success")
            else:
                reason = message.split('| Reason: ')[1] if '| Reason: ' in message else "Unknown reason"
                log_song_data(song_title, artist, audio_url, upload_date, "Failure", reason)
        else:
            print(f"Failed to extract song data for {url}.")

def main(url): # Added to main.py
    process_urls([url])

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Extract song data from Suno page using Pyppeteer.')
    parser.add_argument('--url', type=str, help='URL of the Suno song, playlist, or artist page')
    parser.add_argument('--playlist', action='store_true', help='Prompt for multiple Suno song URLs')
    args = parser.parse_args()

    if args.url:
        main(args.url)
    elif args.playlist:
        urls = []
        while True:
            url = input("Please enter the Suno song, playlist, or artist URL (or just hit Enter to stop): ")
            if url == '':
                break
            if is_valid_url(url):
                urls.append(url)
            else:
                print("Invalid URL. Please enter a valid Suno song, playlist, or artist URL.")

        urls = list(set(urls))  # Remove duplicates before processing
        process_urls(urls)
    else:
        url = input("Please enter the Suno song, playlist, or artist URL: ")
        main(url)

================================================
File: DL2/main.py
================================================

from suno.processing import process_urls
from utils.artwork_utils import process_directory as process_artwork_directory
from utils.get_metadata_utils import process_directory as process_metadata_directory
from utils.url_utils import is_valid_url

def _menu_clear_log():
    """Clear the song_data.txt log file."""
    try:
        with open("song_data.txt", "w") as log_file:
            log_file.write("")
        print("Log file cleared successfully.")
    except Exception as e:
        print(f"Error clearing log file: {e}")

def _menu_download_song():
    """Download a single song from a URL."""
    url = input("Enter the song URL: ")
    if is_valid_url(url):
        process_urls([url])
    else:
        print("Invalid URL.")

def _menu_download_playlist():
    """Download a playlist from a URL."""
    url = input("Enter the playlist URL: ")
    if is_valid_url(url):
        process_urls([url])
    else:
        print("Invalid URL.")

def _menu_download_artist_collection():
    """Download an artist collection from a URL."""
    url = input("Enter the artist collection URL: ")
    if is_valid_url(url):
        process_urls([url])
    else:
        print("Invalid URL.")

def main():
    downloads_dir = './downloads'  # Define the downloads directory here

    while True:
        print("\nChoose an option:")
        print("1. Check for embedded artwork in MP3 files")
        print("2. Embed artwork in MP3 files")
        print("3. Get metadata for MP3 files")
        print("4. View Log (song_data.txt)")
        print("5. Download Song")
        print("6. Download Playlist")
        print("7. Download Artist Collection")
        print("8. Clear Log")
        print("0. Exit")

        choice = input("Enter your choice: ")

        if choice == '1':
            process_artwork_directory(downloads_dir)  # Check for embedded artwork
        elif choice == '2':
            process_artwork_directory(downloads_dir)  # Embed artwork
        elif choice == '3':
            process_metadata_directory(downloads_dir)  # Process metadata
        elif choice == '4':
            try:
                with open("song_data.txt", "r") as log_file:
                    print(log_file.read())
            except FileNotFoundError:
                print("Log file not found.")
        elif choice == '5':
            _menu_download_song()
        elif choice == '6':
            _menu_download_playlist()
        elif choice == '7':
            _menu_download_artist_collection()
        elif choice == '8':
            _menu_clear_log()
        elif choice == '0':
            print("Exiting...")
            break
        else:
            print("Invalid choice. Please try again.")

if __name__ == "__main__":
    main()

================================================
File: DL2/suno/exceptions.py
================================================

class DownloadError(Exception):
    pass

class MetadataError(Exception):
    pass

================================================
File: DL2/suno/fetch.py
================================================

# suno/fetch.py

from datetime import datetime
from pyppeteer import launch
from utils.url_utils import extract_song_id, is_valid_url

async def fetch_song_data(url): # This moved to suno/fetch.py
    try:
        browser = await launch(headless=True)
        page = await browser.newPage()
        await page.goto(url, {'waitUntil': 'networkidle2'})

        title = await page.evaluate('document.title')
        audio_url = await page.evaluate('''
            () => {
                const metaTags = document.getElementsByTagName('meta');
                for (let tag of metaTags) {
                    if (tag.getAttribute('property') === 'og:audio') {
                        return tag.getAttribute('content');
                    }
                }
                return null;
            }
        ''')

        upload_date = await scrape_upload_date(page)
        album_art_url = await scrape_album_art(page)

        return title, audio_url, upload_date, album_art_url
    except Exception as e:
        print(f"Error fetching data for {url}: {e}")
        return None, None, None, None
    finally:
        await browser.close()

async def scrape_upload_date(page):  # This moved to suno/fetch.py
    upload_date_str = await page.evaluate('''
        () => {
            const dateSpan = document.querySelector('.items-center.mt-6 span[title]');
            return dateSpan ? dateSpan.getAttribute('title') : null;
        }
    ''')

    # Normalize the date format
    if upload_date_str:
        try:
            # Parse the date string
            upload_date = datetime.strptime(upload_date_str, '%B %d, %Y at %I:%M %p')
            # Convert to ISO 8601 format
            return upload_date.isoformat()
        except ValueError:
            print(f"Error parsing date: {upload_date_str}")
            return None

    return None

async def scrape_album_art(page):  # This moved to suno/fetch.py
    album_art_url = await page.evaluate('''
        () => {
            const metaTags = document.getElementsByTagName('meta');
            for (let tag of metaTags) {
                if (tag.getAttribute('property') === 'og:image') {
                    return tag.getAttribute('content');
                }
            }
            return null;
        }
    ''')
    return album_art_url

================================================
File: DL2/suno/processing.py
================================================

# suno/processing.py

import asyncio

from utils.artist_song_utils import fetch_artist_songs
from utils.fetch_utils import extract_artist_and_title, fetch_song_data
from utils.file_utils import download_song
from utils.logging_utils import log_song_data
from utils.playlist_utils import fetch_playlist_songs

def process_urls(urls):
    loop = asyncio.get_event_loop()
    success_count = 0
    failure_count = 0

    for url in urls:
        if 'playlist' in url:
            song_urls = loop.run_until_complete(fetch_playlist_songs(url))
            for song_url in song_urls:
                title, audio_url, upload_date, album_art_url = loop.run_until_complete(fetch_song_data(song_url))

                if title and audio_url:
                    song_title, artist = extract_artist_and_title(title)
                    print(f"Title: {song_title}")
                    print(f"Artist: {artist}")
                    print(f"Audio URL: {audio_url}")
                    print(f"Upload Date: {upload_date}")
                    print(f"Album Art URL: {album_art_url}")

                    # Download the song and log the result
                    success, message = download_song(audio_url, artist, song_title, upload_date, album_art_url)
                    print(message)
                    if success:
                        success_count += 1
                    else:
                        failure_count += 1

                    # Log the song data
                    log_song_data(song_title, artist, audio_url, upload_date, "Success" if success else "Failure", message)
                else:
                    print(f"Failed to extract song data for {song_url}.")
                    log_song_data("N/A", "N/A", url, "N/A", "Failure", "Failed to extract playlist")
        elif '@' in url:
            song_urls = loop.run_until_complete(fetch_artist_songs(url))
            for song_url in song_urls:
                title, audio_url, upload_date, album_art_url = loop.run_until_complete(fetch_song_data(song_url))

                if title and audio_url:
                    song_title, artist = extract_artist_and_title(title)
                    print(f"Title: {song_title}")
                    print(f"Artist: {artist}")
                    print(f"Audio URL: {audio_url}")
                    print(f"Upload Date: {upload_date}")
                    print(f"Album Art URL: {album_art_url}")

                    # Download the song and log the result
                    success, message = download_song(audio_url, artist, song_title, upload_date, album_art_url)
                    print(message)
                    if success:
                        success_count += 1
                    else:
                        failure_count += 1

                    # Log the song data
                    log_song_data(song_title, artist, audio_url, upload_date, "Success" if success else "Failure", message)
                else:
                    print(f"Failed to extract song data for {song_url}.")
                    log_song_data("N/A", "N/A", url, "N/A", "Failure", "Failed to extract artist page")
        else:
            title, audio_url, upload_date, album_art_url = loop.run_until_complete(fetch_song_data(url))

            if title and audio_url:
                song_title, artist = extract_artist_and_title(title)
                print(f"Title: {song_title}")
                print(f"Artist: {artist}")
                print(f"Audio URL: {audio_url}")
                print(f"Upload Date: {upload_date}")
                print(f"Album Art URL: {album_art_url}")

                # Download the song and log the result
                success, message = download_song(audio_url, artist, song_title, upload_date, album_art_url)
                print(message)
                if success:
                    success_count += 1
                else:
                    failure_count += 1

                # Log the song data
                log_song_data(song_title, artist, audio_url, upload_date, "Success" if success else "Failure", message)


            else:
                print(f"Failed to extract song data for {url}.")
                log_song_data("N/A", "N/A", url, "N/A", "Failure", "Failed to extract song data")

    print(f"\nSummary: {success_count} songs downloaded successfully, {failure_count} failed.")

def main(url):
    process_urls([url])

================================================
File: DL2/suno/.gitignore
================================================

config.py
cli.py
core.py
helpers.py

================================================
File: DL2/tests/test_get_suno.py
================================================

import pytest
import asyncio
from unittest.mock import patch, MagicMock
from Sunodl.get_suno import fetch_song_data, scrape_upload_date, scrape_album_art, extract_artist_and_title, is_valid_url

SONG_URL = "<https://suno.com/song/6a6bdd56-d583-4e0a-9869-b98a8c72a37b>"
PLAYLIST_URL = "<https://suno.com/playlist/99e5d0c6-b1f7-451d-830d-5c272d114cd6>"
ARTIST_URL = "<https://suno.com/@happygoth>"

@pytest.mark.asyncio
async def test_fetch_song_data():
    with patch('pyppeteer.launch') as mock_launch:
        mock_browser = MagicMock()
        mock_page = MagicMock()

        mock_launch.return_value = mock_browser
        mock_browser.newPage.return_value = mock_page

        mock_page.evaluate.side_effect = [
            "Shadows of the Holler by @timmo",  # Title without the '| Suno'
            "https://cdn1.suno.ai/6a6bdd56-d583-4e0a-9869-b98a8c72a37b.mp3",  # Correct Audio URL
            "February 26, 2024 at 09:51 AM",  # Correct Upload Date
            "https://cdn2.suno.ai/image_large_768adf51-ba69-44c7-9c6a-a488babb73e7.jpeg"  # Optional Album Art URL
        ]

        result = await fetch_song_data(SONG_URL)

        assert result == (
            "Shadows of the Holler",
            "timmo",
            "2024-02-26T09:51:00",
            "https://cdn2.suno.ai/image_large_768adf51-ba69-44c7-9c6a-a488babb73e7.jpeg"
        )

@pytest.mark.asyncio
async def test_scrape_upload_date():
    with patch('pyppeteer.launch') as mock_launch:
        mock_browser = MagicMock()
        mock_page = MagicMock()

        mock_launch.return_value = mock_browser
        mock_browser.newPage.return_value = mock_page

        future = asyncio.Future()
        future.set_result("January 1, 2023 at 12:00 PM")
        mock_page.evaluate.return_value = future

        upload_date = await scrape_upload_date(mock_page)
        assert upload_date == "2023-01-01T12:00:00"

@pytest.mark.asyncio
async def test_scrape_album_art():
    with patch('pyppeteer.launch') as mock_launch:
        mock_browser = MagicMock()
        mock_page = MagicMock()

        mock_launch.return_value = mock_browser
        mock_browser.newPage.return_value = mock_page

        future = asyncio.Future()
        future.set_result("http://album.art/url.jpg")
        mock_page.evaluate.return_value = future

        album_art_url = await scrape_album_art(mock_page)
        assert album_art_url == "http://album.art/url.jpg"

def test_extract_artist_and_title():
    title = "Test Song Title by @TestArtist - Some Info"
    song_title, artist = extract_artist_and_title(title)
    assert song_title == "Test_Song_Title"
    assert artist == "TestArtist"

def test_is_valid_url():
    assert is_valid_url(SONG_URL) == True
    assert is_valid_url(PLAYLIST_URL) == True
    assert is_valid_url(ARTIST_URL) == True
    assert is_valid_url("<https://invalid-url.com>") == False

================================================
File: DL2/tests/test_utils/test_artwork_utils.py
================================================

# tests/test_utils/test_artwork_utils.py

import os
import pytest
from utils.artwork_utils import embed_artwork, check_embedded_artwork, process_directory
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, APIC

@pytest.fixture
def setup_mp3_with_artwork(tmp_path):
    """Fixture to create a temporary valid MP3 file with a temporary image file."""
    # Path for the temporary files
    mp3_file = tmp_path / "test_song.mp3"
    image_file = tmp_path / "cover.jpg"

    # Create a valid MP3 file (using a small sample MP3 for testing)
    with open(mp3_file, 'wb') as f:
        f.write(b'\x49\x44\x33\x03\x00\x00\x00\x00\x00\x00\x00\x00')  # Minimal ID3 header

    # Create a dummy image file
    with open(image_file, 'wb') as f:
        f.write(b'\0' * 1024)  # Just create a dummy image file

    return mp3_file, image_file

def test_embed_artwork(setup_mp3_with_artwork):
    mp3_file, image_file = setup_mp3_with_artwork
    embed_artwork(mp3_file, image_file)

    # Check if artwork was embedded
    audio = MP3(mp3_file, ID3=ID3)
    assert any(isinstance(tag, APIC) for tag in audio.tags.values())

def test_check_embedded_artwork(setup_mp3_with_artwork):
    mp3_file, image_file = setup_mp3_with_artwork
    embed_artwork(mp3_file, image_file)

    assert check_embedded_artwork(mp3_file) is True

def test_process_directory(tmp_path):
    """Test that process_directory correctly processes MP3 files and embeds artwork."""
    mp3_file = tmp_path / "test_song.mp3"
    image_file = tmp_path / "cover.jpg"

    # Create a valid MP3 file
    with open(mp3_file, 'wb') as f:
        f.write(b'\x49\x44\x33\x03\x00\x00\x00\x00\x00\x00\x00\x00')  # Minimal ID3 header

    # Create a dummy image file
    with open(image_file, 'wb') as f:
        f.write(b'\0' * 1024)

    # Call process_directory
    os.makedirs(tmp_path / "downloads", exist_ok=True)
    mp3_dest = (tmp_path / "downloads" / "test_song.mp3")
    mp3_file.rename(mp3_dest)

    jpg_dest = (tmp_path / "downloads" / "cover.jpg")
    image_file.rename(jpg_dest)

    # Run the function
    process_directory(tmp_path / "downloads")

    # Verify that artwork was embedded
    assert check_embedded_artwork(mp3_dest) is True

================================================
File: DL2/utils/artist_song_utils.py
================================================

from pyppeteer import launch

async def fetch_artist_songs(artist_url):
    try:
        browser = await launch(headless=True)
        page = await browser.newPage()

        await page.goto(artist_url, {'waitUntil': 'networkidle2'})

        # Extract all song URLs from the artist's page
        song_links = await page.evaluate('''
            () => {
                const links = [];
                const songElements = document.querySelectorAll('a[href^="/song/"]');
                songElements.forEach(el => links.push('https://suno.com' + el.getAttribute('href')));
                return links;
            }
        ''')
        return song_links
    except Exception as e:
        print(f"Error fetching artist data for {artist_url}: {e}")
        return []
    finally:
        await browser.close()

================================================
File: DL2/utils/artwork_utils.py
================================================

import os
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, APIC

def embed_artwork(mp3_file, image_file):
    """Embeds artwork into the specified MP3 file."""
    audio = MP3(mp3_file, ID3=ID3)

    # Read the image file
    with open(image_file, 'rb') as img:
        image_data = img.read()

    # Create an APIC tag for the artwork
    audio.tags.add(APIC(
        encoding=3,  # 3 is for ID3v2.3
        mime='image/jpeg',  # Change to 'image/png' if the image is a PNG
        type=3,  # 3 is for front cover
        desc='Cover',
        data=image_data
    ))

    # Save changes to the MP3 file
    audio.save()
    print(f"Artwork embedded in {mp3_file}")

def check_embedded_artwork(mp3_file):
    """Checks if there is embedded artwork in the specified MP3 file."""
    try:
        audio = MP3(mp3_file, ID3=ID3)
        if audio.tags:
            for tag in audio.tags.values():
                if isinstance(tag, APIC):
                    print(f"Artwork found in {mp3_file}: {tag.mime}, Description: {tag.desc}")
                    return True
        print(f"No artwork found in {mp3_file}.")
        return False
    except Exception as e:
        print(f"Error reading {mp3_file}: {e}")
        return False

def process_directory(downloads_dir):
    """Recursively processes the downloads directory for MP3 files."""
    for root, _, files in os.walk(downloads_dir):
        for file in files:
            if file.endswith('.mp3'):
                mp3_file_path = os.path.join(root, file)
                # Check for embedded artwork
                check_embedded_artwork(mp3_file_path)
                # Construct the expected JPG file path for embedding
                jpg_file_path = os.path.splitext[mp3_file_path](0) + '.jpg'
                if os.path.exists(jpg_file_path):
                    embed_artwork(mp3_file_path, jpg_file_path)  # Embed artwork
                else:
                    print(f"No artwork found for {mp3_file_path}")

if __name__ == "__main__":
    downloads_dir = './downloads'  # Change this to your downloads directory if needed
    process_directory(downloads_dir)  # Start processing the directory

================================================
File: DL2/utils/fetch_utils.py
================================================

import os

import re
from utils.file_utils import download_album_art, download_file, sanitize_filename
from utils.get_metadata_utils import embed_metadata
from utils.logging_utils import log_song_data
from pyppeteer import launch
from datetime import datetime

async def fetch_song_data(url):
    try:
        browser = await launch(headless=True)
        page = await browser.newPage()
        await page.goto(url, {'waitUntil': 'networkidle2'})

        title = await page.evaluate('document.title')
        audio_url = await page.evaluate('''
            () => {
                const metaTags = document.getElementsByTagName('meta');
                for (let tag of metaTags) {
                    if (tag.getAttribute('property') === 'og:audio') {
                        return tag.getAttribute('content');
                    }
                }
                return null;
            }
        ''')

        upload_date = await scrape_upload_date(page)
        album_art_url = await scrape_album_art(page)

        return title, audio_url, upload_date, album_art_url
    except Exception as e:
        print(f"Error fetching data for {url}: {e}")
        return None, None, None, None
    finally:
        await browser.close()

async def scrape_upload_date(page):
    upload_date_str = await page.evaluate('''
        () => {
            const dateSpan = document.querySelector('.items-center.mt-6 span[title]');
            return dateSpan ? dateSpan.getAttribute('title') : null;
        }
    ''')

    # Normalize the date format
    if upload_date_str:
        try:
            # Parse the date string
            upload_date = datetime.strptime(upload_date_str, '%B %d, %Y at %I:%M %p')
            # Convert to ISO 8601 format
            return upload_date.isoformat()
        except ValueError:
            print(f"Error parsing date: {upload_date_str}")
            return None

    return None

async def scrape_album_art(page):
    album_art_url = await page.evaluate('''
        () => {
            const metaTags = document.getElementsByTagName('meta');
            for (let tag of metaTags) {
                if (tag.getAttribute('property') === 'og:image') {
                    return tag.getAttribute('content');
                }
            }
            return null;
        }
    ''')
    return album_art_url

async def scrape_upload_date(page):
    upload_date_str = await page.evaluate('''
        () => {
            const dateSpan = document.querySelector('.items-center.mt-6 span[title]');
            return dateSpan ? dateSpan.getAttribute('title') : null;
        }
    ''')

    if upload_date_str:
        try:
            upload_date = datetime.strptime(upload_date_str, '%B %d, %Y at %I:%M %p')
            return upload_date.isoformat()
        except ValueError:
            print(f"Error parsing date: {upload_date_str}")
            return None

    return None

def extract_artist_and_title(title):
    match = re.search(r'^(.*?) by @(.*?)\s*[\|\-]', title)
    if match:
        song_title = match.group(1).strip().replace(' ', '_')  # Sanitize title
        artist = match.group(2).strip()
        return song_title, artist
    return None, None

async def process_song(url):
    title, audio_url, upload_date, album_art_url = await fetch_song_data(url)

    if title and audio_url:
        song_title, artist = extract_artist_and_title(title)

        print(f"Processing song: {song_title} by {artist}")
        print(f"Audio URL: {audio_url}")
        print(f"Upload Date: {upload_date}")

        # Download the album art
        album_art_path = await download_album_art(album_art_url, artist, song_title)

        # Download the song
        sanitized_title = sanitize_filename(song_title)
        file_path = f'./downloads/{artist}/{sanitized_title}.mp3'

        if os.path.exists(file_path):
            print(f"Skipped download. File already exists: {file_path}")
            log_song_data(song_title, artist, audio_url, upload_date, "Failure", "File already exists")
            return

        try:
            await download_file(audio_url, file_path)
            print(f"Downloaded song to: {file_path}")

            # Embed metadata
            embed_metadata(file_path, song_title, artist, upload_date, album_art_path)
            log_song_data(song_title, artist, audio_url, upload_date, "Success")

        except Exception as e:
            print(f"Error downloading song: {e}")
            log_song_data(song_title, artist, audio_url, upload_date, "Failure", str(e))
    else:
        print(f"Failed to extract song data for {url}.")
        log_song_data("", "", "", "", "Failure", "Failed to extract song data")

================================================
File: DL2/utils/file_utils.py
================================================

import os
import re
import mutagen
import requests
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, TIT2, TPE1, TALB, TXXX, APIC
from tqdm import tqdm

def sanitize_filename(title):
    return re.sub(r'[<>:"/\\|?*]', '', title).strip()

def ensure_directories_exist(artist):
    # Use an absolute path for downloads
    downloads_dir = os.path.join(os.getcwd(), 'downloads')

    # Create downloads directory if it doesn't exist
    if not os.path.exists(downloads_dir):
        os.makedirs(downloads_dir)
        print(f'Created directory: {downloads_dir}')

    # Create artist directory within downloads
    artist_dir = os.path.join(downloads_dir, artist)
    if not os.path.exists(artist_dir):
        os.makedirs(artist_dir)
        print(f'Created directory: {artist_dir}')

def download_album_art(album_art_url, artist, title): # unused. The download song function now handles the artwork as well
    if not album_art_url:
        return None

    ensure_directories_exist(artist)  # Ensure directories exist before downloading

    try:
        response = requests.get(album_art_url)
        response.raise_for_status()

        # Save the album art in the artist's directory
        art_filename = sanitize_filename(title) + '.jpg'
        art_path = os.path.join('./downloads', artist, art_filename)

        with open(art_path, 'wb') as art_file:
            art_file.write(response.content)

        return art_path
    except Exception as e:
        print(f"Failed to download album art: {e}")
        return None

def download_song(mp3_url, artist, title, upload_date, album_art_url):
    ensure_directories_exist(artist)

    sanitized_title = sanitize_filename(title)
    sanitized_artist = sanitize_filename(artist)
    mp3_file_path = os.path.join('./downloads', sanitized_artist, f'{sanitized_title}.mp3')
    album_art_file_path = os.path.join('./downloads', sanitized_artist, f'{sanitized_title}.jpeg')

    if os.path.exists(mp3_file_path) and os.path.exists(album_art_file_path):
        return False, f'Skipped download. Files already exist: {mp3_file_path}, {album_art_file_path}'

    try:
        # Download the MP3 file
        download_file(mp3_url, mp3_file_path)

        # Download the album art
        if album_art_url:
            download_file(album_art_url, album_art_file_path)

        # Set metadata using Mutagen
        audio = MP3(mp3_file_path, ID3=ID3)
        audio.tags = ID3()  # Create ID3 tags if they don't exist
        audio.tags.add(TIT2(encoding=3, text=title))
        audio.tags.add(TPE1(encoding=3, text=artist))
        audio.tags.add(TALB(encoding=3, text=''))
        audio.tags.add(TXXX(encoding=3, desc='Upload Date', text=upload_date))

        # Embed the album art
        if os.path.exists(album_art_file_path):
            with open(album_art_file_path, 'rb') as img_file:
                img_data = img_file.read()
                audio.tags.add(APIC(
                    encoding=3,
                    mime='image/jpeg',
                    type=3,
                    desc='Cover',
                    data=img_data
                ))

        audio.save()
        return True, f'Downloaded and tagged: {mp3_file_path}'
    except requests.exceptions.HTTPError as http_err:
        return False, f'HTTP error occurred: {http_err}'
    except IOError as io_err:
        return False, f'File I/O error occurred: {io_err}'
    except mutagen.MutagenError as mutagen_err:
        return False, f'Mutagen error occurred: {mutagen_err}'
    except Exception as err:
        return False, f'Other error occurred: {err}'

def check_embedded_artwork(mp3_file):
    """Checks if there is embedded artwork in the specified MP3 file."""
    try:
        audio = MP3(mp3_file, ID3=ID3)
        if audio.tags:
            for tag in audio.tags.values():
                if isinstance(tag, APIC):
                    print(f"Artwork found in {mp3_file}: {tag.mime}, Description: {tag.desc}")
                    return True
        print(f"No artwork found in {mp3_file}.")
        return False
    except Exception as e:
        print(f"Error reading {mp3_file}: {e}")
        return False

def process_directory(downloads_dir):
    """Recursively processes the downloads directory to check for embedded artwork."""
    for root, _, files in os.walk(downloads_dir):
        for file in files:
            if file.endswith('.mp3'):
                mp3_file_path = os.path.join(root, file)
                check_embedded_artwork(mp3_file_path)

def download_file(url, path):
    response = requests.get(url)
    response.raise_for_status()
    with open(path, 'wb') as file:
        file.write(response.content)

================================================
File: DL2/utils/get_metadata_utils.py
================================================

# utils/get_metadata_utils.py

import os
from mutagen.mp3 import MP3
from mutagen.id3 import ID3, TIT2, TPE1, TALB, TXXX, APIC

def format_length(seconds):
    """Convert seconds to mm:ss format."""
    minutes = int(seconds // 60)
    seconds = int(seconds % 60)
    return f"{minutes:02}:{seconds:02}"

def print_metadata(file_path):
    metadata = {}  # Initialize metadata dictionary
    try:
        audio = MP3(file_path, ID3=ID3)

        # Get the song ID
        song_id = audio.get('TXXX:Song ID', None)
        metadata['Song ID'] = song_id.text[0] if song_id else 'Not available'

        # Check for corresponding JPG file
        jpg_file_path = os.path.splitext(file_path)[0] + '.jpg'
        if os.path.exists(jpg_file_path):
            metadata['Album Art'] = jpg_file_path
        else:
            # Check for album art in the tags
            album_art = 'Not available'
            if audio.tags:
                for tag in audio.tags.values():
                    if isinstance(tag, APIC):
                        album_art = 'Embedded art found'
                        break
            metadata['Album Art'] = album_art

        title = audio.tags.get('TIT2')
        artist = audio.tags.get('TPE1')
        upload_date = audio.tags.get('TXXX:Upload Date')  # Retrieve upload date
        length = audio.info.length
        bitrate = audio.info.bitrate

        print("Metadata for:", file_path)
        print("Song ID:", metadata['Song ID'])
        print("Title:", title.text[0] if title else "N/A")
        print("Artist:", artist.text[0] if artist else "N/A")
        print("Upload Date:", upload_date.text[0] if upload_date else "N/A")  # Display upload date
        print("Length:", format_length(length))
        print("Bitrate: {} kbps".format(bitrate // 1000))
        print("Artwork:", metadata['Album Art'])  # Print the final result for Album Art

    except Exception as e:
        print(f"Error reading metadata for {file_path}: {e}")

def list_mp3_files(downloads_dir):
    """List all MP3 files in the downloads directory."""
    mp3_files = []
    for root, _, files in os.walk(downloads_dir):
        for file in files:
            if file.endswith('.mp3'):
                mp3_files.append(os.path.join(root, file))
    return mp3_files

def process_directory(downloads_dir):
    """Process all MP3 files in the downloads directory."""
    mp3_files = list_mp3_files(downloads_dir)

    if not mp3_files:
        print("No MP3 files found in the downloads directory.")
    else:
        for file_path in mp3_files:
            print_metadata(file_path)

def embed_metadata(file_path, title, artist, upload_date, album_art_path):
    audio = MP3(file_path, ID3=ID3)
    audio.tags = ID3()  # Create ID3 tags if they don't exist
    audio.tags.add(TIT2(encoding=3, text=title))
    audio.tags.add(TPE1(encoding=3, text=artist))
    audio.tags.add(TALB(encoding=3, text=''))
    audio.tags.add(TXXX(encoding=3, desc='Upload Date', text=upload_date))

    if album_art_path:
        with open(album_art_path, 'rb') as img_file:
            img_data = img_file.read()
            audio.tags.add(APIC(
                encoding=3,
                mime='image/jpeg',
                type=3,
                desc='Cover',
                data=img_data
            ))

    audio.save()  # Save the changes

================================================
File: DL2/utils/logging_utils.py
================================================

from datetime import datetime

def log_song_data(title, artist, audio_url, upload_date, status, reason=""):
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_entry = (
        f"{timestamp} | Title: {title} | Artist: {artist} | "
        f"Audio URL: {audio_url} | Upload Date: {upload_date} | "
        f"Status: {status}"
    )
    if status == "Failure" and reason:
        log_entry += f" | Reason: {reason}"

    log_entry += "\n"

    try:
        with open("song_data.txt", "a") as f:
            f.write(log_entry)
    except IOError as e:
        print(f"Failed to write to log: {e}")

================================================
File: DL2/utils/metadata_utils.py
================================================

import os
import re
from datetime import datetime

def extract_artist_and_title(title):
    match = re.search(r'^(.*?) by @(.*?)\s*[\|\-]', title)
    if match:
        song_title = match.group(1).strip().replace(' ', '_')  # Sanitize title
        artist = match.group(2).strip()
        return song_title, artist
    return None, None

================================================
File: DL2/utils/playlist_utils.py
================================================

from pyppeteer import launch

from utils.fetch_utils import fetch_song_data
from utils.logging_utils import log_song_data
from utils.metadata_utils import extract_artist_and_title

async def fetch_playlist_songs(playlist_url):
    try:
        browser = await launch(headless=True)
        page = await browser.newPage()

        await page.goto(playlist_url, {'waitUntil': 'networkidle2'})

        # Extract all song URLs from the playlist
        song_links = await page.evaluate('''
            () => {
                const links = [];
                const songElements = document.querySelectorAll('a[href^="/song/"]');
                songElements.forEach(el => links.push('https://suno.com' + el.getAttribute('href')));
                return links;
            }
        ''')
        return song_links
    except Exception as e:
        print(f"Error fetching playlist data for {playlist_url}: {e}")
        return []
    finally:
        await browser.close()


================================================
File: DL2/utils/url_utils.py
================================================

import re

def is_valid_url(url):
    pattern = r'^https?://suno\.com/song/[a-f0-9\-]+$'
    playlist_pattern = r'^https?://suno\.com/playlist/[a-f0-9\-]+$'
    artist_pattern = r'^https?://suno\.com/@[a-zA-Z0-9_-]+$'
    return (re.match(pattern, url) or
            re.match(playlist_pattern, url) or
            re.match(artist_pattern, url))

def extract_song_id(url):
    """Extract the song ID from the URL."""
    match = re.search(r'song/([a-f0-9\-]+)', url)
    return match.group(1) if match else None

================================================
File: DL3/README.md
================================================

# Suno Music downloader

A tauri app to easily download entire Suno playlists in a few clicks

================================================
File: DL3/index.html
================================================

<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Suno Music Downloader</title>
</head>

<body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
</body>

</html>

================================================
File: DL3/postcss.config.cjs
================================================

module.exports = {
    plugins: {
        'postcss-preset-mantine': {},
        'postcss-simple-vars': {
            variables: {
                'mantine-breakpoint-xs': '36em',
                'mantine-breakpoint-sm': '48em',
                'mantine-breakpoint-md': '62em',
                'mantine-breakpoint-lg': '75em',
                'mantine-breakpoint-xl': '88em',
            },
        },
    },
};

================================================
File: DL3/vite.config.ts
================================================

import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// @ts-expect-error process is a nodejs global
const host = process.env.TAURI_DEV_HOST;

// <https://vitejs.dev/config/>
export default defineConfig(async () => ({
    plugins: [react()],

    // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
    //
    // 1. prevent vite from obscuring rust errors
    clearScreen: false,
    // 2. tauri expects a fixed port, fail if that port is not available
    server: {
        port: 1420,
        strictPort: true,
        host: host || false,
        hmr: host
            ? {
                protocol: "ws",
                host,
                port: 1421,
            }
            : undefined,
        watch: {
            // 3. tell vite to ignore watching `src-tauri`
            ignored: ["**/src-tauri/**"],
        },
    },
    css: {
        postcss: './postcss.config.cjs'
    }
}));

================================================
File: DL3/docs/index.htm
================================================

<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Suno Music Downloader</title>
    <link rel="stylesheet" href="./style.css" type="text/css" />
    <script type="text/javascript">
        (function (c, l, a, r, i, t, y) {
            c[a] = c[a] || function () { (c[a].q = c[a].q || []).push(arguments) };
            t = l.createElement(r); t.async = 1; t.src = "https://www.clarity.ms/tag/" + i;
            y = l.getElementsByTagName[r](0); y.parentNode.insertBefore(t, y);
        })(window, document, "clarity", "script", "pt8ptgfe4u");
    </script>
    <script>
        async function getReleaseAssetUrl(repo, tag = 'latest', assetRegex) {
            const apiUrl = `https://api.github.com/repos/${repo}/releases/${tag}`;

            try {
                const response = await fetch(apiUrl, {
                    headers: {
                        Accept: 'application/vnd.github.v3+json',
                    },
                });

                if (!response.ok) {
                    throw new Error(`GitHub API returned ${response.status}: ${response.statusText}`);
                }

                const release = await response.json();
                const asset = release.assets.find(asset => assetRegex.test(asset.name));

                if (!asset) {
                    throw new Error(`No asset found matching ${assetRegex}`);
                }

                return asset.browser_download_url;
            } catch (error) {
                console.error('Error fetching release asset URL:', error.message);
                return null;
            }
        }


        getReleaseAssetUrl('DrummerSi/suno-downloader', 'latest', /\.msi/)
            .then(url => {
                if (url) {
                    console.log('Download URL:', url);
                    document.getElementById('download-windows').href = url;
                } else {
                    console.log('No matching asset found.');
                }
            });

    </script>
</head>

<body>

    <section class="hero">
        <div class="container">
            <h1>Suno Music Downloader</h1>
            <p>Quickly and easily download your Suno music playlists</p>
            <div class="buttons">
                <a href="https://github.com/DrummerSi/suno-downloader/releases" id="download-windows"
                    class="btn primary">Download for Windows</a>
                <a href="https://github.com/DrummerSi/suno-downloader/" class="btn secondary">View source</a>
            </div>

            <img src="./suno-app.png"
                style="max-width: 100%; margin-top: 20px; filter: drop-shadow(0px 0px 5px #000); " />
        </div>
    </section>

</body>

</html>

================================================
File: DL3/docs/style.css
================================================

body {
  margin: 0;
  font-family: Arial, sans-serif;
  background-color: #121212; /*Dark background */
  color: #ffffff; /* Light text for contrast*/
}

.hero {
  padding: 60px 20px 20px; /*Add padding at the top*/
  text-align: center;
  background-color: #121212;
}

.container {
  max-width: 800px;
  margin: 0 auto;
}

h1 {
  font-size: 2.5em;
  margin-bottom: 20px;
}

p {
  font-size: 1.2em;
  margin-bottom: 30px;
}

.buttons {
  display: flex;
  justify-content: center;
  gap: 15px;
}

.btn {
  text-decoration: none;
  padding: 10px 20px;
  border-radius: 5px;
  font-size: 1em;
  transition: background-color 0.3s;
}

.btn.primary {
  background-color: #1e88e5; /*Primary button color*/
  color: #ffffff;
}

.btn.primary:hover {
  background-color: #1565c0; /*Darker shade on hover*/
}

.btn.secondary {
  background-color: #ffffff; /*Secondary button color*/
  color: #121212;
}

.btn.secondary:hover {
  background-color: #e0e0e0; /*Slightly darker on hover*/
}

================================================
File: DL3/src/App.css
================================================

html, body, #root {
    height: 100vh;
}

/* .logo.vite:hover {
  filter: drop-shadow(0 0 2em #747bff);
}

.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafb);
}
:root {
  font-family: Inter, Avenir, Helvetica, Arial, sans-serif;
  font-size: 16px;
  line-height: 24px;
  font-weight: 400;

  color: #0f0f0f;
  background-color: #f6f6f6;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-text-size-adjust: 100%;
}

.container {
  margin: 0;
  padding-top: 10vh;
  display: flex;
  flex-direction: column;
  justify-content: center;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: 0.75s;
}

.logo.tauri:hover {
  filter: drop-shadow(0 0 2em #24c8db);
}

.row {
  display: flex;
  justify-content: center;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}

a:hover {
  color: #535bf2;
}

h1 {
  text-align: center;
}

input,
button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  color: #0f0f0f;
  background-color: #ffffff;
  transition: border-color 0.25s;
  box-shadow: 0 2px 2px rgba(0, 0, 0, 0.2);
}

button {
  cursor: pointer;
}

button:hover {
  border-color: #396cd8;
}
button:active {
  border-color: #396cd8;
  background-color: #e8e8e8;
}

input,
button {
  outline: none;
}

# greet-input {
  margin-right: 5px;
}

@media (prefers-color-scheme: dark) {
  :root {
    color: #f6f6f6;
    background-color: #2f2f2f;
  }

  a:hover {
    color: #24c8db;
  }

  input,
  button {
    color: #ffffff;
    background-color: #0f0f0f98;
  }
  button:active {
    background-color: #0f0f0f69;
  }
} */

================================================
File: DL3/src/App.tsx
================================================

import "./App.css";

import * as path from "@tauri-apps/api/path"

import { ActionIcon, AppShell, Badge, Box, Button, CloseButton, Divider, FileInput, Flex, Group, Image, NavLink, Paper, Popover, Progress, Stack, Table, Text, TextInput, Title } from "@mantine/core"
import { BaseDirectory, create } from "@tauri-apps/plugin-fs";
import { IconBrandGithub, IconCoffee, IconFolder, IconFolderFilled, IconHelp, IconHelpCircle, IconHelpCircleFilled, IconHelpSmall, IconLink, IconSolarElectricity, IconVinyl } from "@tabler/icons-react";
import Suno, { IPlaylist, IPlaylistClip, IPlaylistClipStatus } from "./services/Suno";
import { addImageToMp3, deletePath, ensureDir, writeFile } from "./services/RustFunctions";
import { delay, getRandomBetween, showError, showSuccess } from "./services/Utils";
import { useEffect, useRef, useState } from "react";

import Footer from "./components/Footer";
import SectionHeading from "./components/SectionHeading";
import StatusIcon from "./components/StatusIcon";
import { exit } from '@tauri-apps/plugin-process'
import { fetch } from "@tauri-apps/plugin-http"
import filenamify from "filenamify"
import { invoke } from "@tauri-apps/api/core";
import { modals } from "@mantine/modals";
import { open as openDialog } from "@tauri-apps/plugin-dialog";
import pLimit from "p-limit"
import reactLogo from "./assets/react.svg";
import scrollIntoView from "scroll-into-view-if-needed"
import { sendNotification } from "@tauri-apps/plugin-notification";

function App() {

    const [playlistUrl, setPlaylistUrl] = useState("")
    const [saveFolder, setSaveFolder] = useState("")
    const [isGettingPlaylist, setIsGettingPLaylist] = useState(false)
    const [isDownloading, setIsDownloading] = useState(false)
    const [downloadPercentage, setDownloadPercentage] = useState(0)
    const [completedItems, setCompletedItems] = useState(0)

    const songTable = useRef<HTMLTableElement>(null);

    const [playlistData, setPlaylistData] = useState<IPlaylist | null>(null)
    const [playlistClips, setPlaylistClips] = useState<IPlaylistClip[]>([])

    const [footerView, setFooterView] = useState<1 | 2>(1)

    const getPlaylist = async () => {
        setIsGettingPLaylist(true)
        setPlaylistData(null)
        setPlaylistClips([])
        try {
            const data = await Suno.getSongsFromPlayList(playlistUrl)
            setPlaylistData(data[0])
            setPlaylistClips(data[1])
        } catch (err) {
            console.log(err)
            showError("Failed to fetch playlist data. Make sure you entered a valid link")
        }
        setIsGettingPLaylist(false)
    }

    const selectOutputFolder = async () => {
        const dir = await openDialog({
            title: "Select Output Folder",
            directory: true,
            canCreateDirectories: true
        })
        if (dir) setSaveFolder(dir)
    }

    const updateClipStatus = (id: string, status: IPlaylistClipStatus) => {
        setPlaylistClips((prevClips) =>
            prevClips.map((clip) =>
                clip.id === id ? { ...clip, status: status } : clip
            )
        )
    }

    const scrollToRow = (row: string) => {
        const node = songTable.current?.querySelector(`tr[data-id="row-${row}"]`)
        if (node) scrollIntoView(node, {
            scrollMode: "if-needed",
            behavior: "smooth",
            block: "end"
        })
    }

    const downloadPlaylist = async () => {
        setDownloadPercentage(0)
        setCompletedItems(0)
        setIsDownloading(true)

        //TODO: Proper error checking
        if (!playlistData || !playlistClips) return

        //Create the output directory if it doesn't exist
        const outputDir = await path.join(saveFolder, filenamify(playlistData.name))
        const tmpDir = await path.join(outputDir, "tmp")
        await ensureDir(outputDir)
        await ensureDir(tmpDir)

        //Reset the status of all clips
        setPlaylistClips((prevClips) =>
            prevClips.map((clip) => ({ ...clip, status: IPlaylistClipStatus.None }))
        )

        const limit = pLimit(5)
        const downloadPromises = playlistClips.map((song) => {
            return limit(async () => {
                updateClipStatus(song.id, IPlaylistClipStatus.Processing)

                scrollToRow(song.id)

                // ─── For Testing Only ────────────────────────
                //await delay(getRandomBetween(800, 2000))

                // ─── Live Downloading ────────────────────────
                const response = await fetch(song.audio_url)
                if (response.status !== 200) {
                    console.log("Failed to download song", song.audio_url)
                    updateClipStatus(song.id, IPlaylistClipStatus.Error)
                    return //continue
                }

                const songBuffer = await response.arrayBuffer()
                const songFileName = `${outputDir}\\${song.no.toString().padStart(2, "0")} - ${filenamify(song.title)}.mp3`
                writeFile(songFileName, songBuffer)
                //Try and download and inject the mp3 image
                const response2 = await fetch(song.image_url)
                if (response2.status === 200) {
                    const imageBuffer = await response2.arrayBuffer()
                    const imageFileName = `${tmpDir}\\${filenamify(song.id)}.jpg`
                    writeFile(imageFileName, imageBuffer)
                    addImageToMp3(songFileName, imageFileName)
                }

                // ─── Update The Playlist Data ────────────────
                updateClipStatus(song.id, IPlaylistClipStatus.Success)
                setCompletedItems((completedItems) => completedItems + 1)
                // const newPercentage = Math.ceil((song.no / playlistClips.length) * 100)
                // if (newPercentage > downloadPercentage) setDownloadPercentage(newPercentage)
            })
        })

        await Promise.all(downloadPromises)

        setIsDownloading(false)
        deletePath(tmpDir)

        //openCompleteModal()
        showSuccess("Playlist downloaded successfully")
    }

    const formatSecondsToTime = (seconds: number) => {
        const roundedSeconds = Math.round(seconds)
        const mins = Math.floor(roundedSeconds / 60)
        const secs = roundedSeconds % 60
        return `${mins}:${secs.toString().padStart(2, "0")}`
    }

    useEffect(() => {
        const initSavePath = async () => {
            const defaultSavePath = await path.audioDir()
            setSaveFolder(defaultSavePath)
        }
        initSavePath()
    }, [])

    useEffect(() => {
        //If we're downloading, show the download progress
        if (isDownloading) {
            setFooterView(2)
        } else {
            setFooterView(1)
        }
    }, [isDownloading])


    useEffect(() => {
        const totalItems = playlistClips.length
        const newPercentage = Math.ceil((completedItems / totalItems) * 100)
        setDownloadPercentage(newPercentage)
    }, [completedItems])


    // const updatePercentage = () => {
    //     const totalItems = playlistClips.length
    //     const completedItems = playlistClips.filter((clip) =>
    //         clip.status === IPlaylistClipStatus.Success
    //     ).length

    //     console.log(JSON.stringify(playlistClips.filter((clip) =>
    //         clip.status === IPlaylistClipStatus.Success
    //     ), null, 4))

    //     const percentage = Math.ceil((completedItems / totalItems) * 100)
    //     console.log(playlistClips, totalItems, completedItems, percentage)
    //     setDownloadPercentage(percentage)
    // }

    const openCompleteModal = () => modals.open({
        title: 'Operation complete',
        centered: true,
        withCloseButton: false,
        children: (
            <Stack gap={20}>
                <Text>Your playlist has been downloaded successfully</Text>
                <Flex justify="flex-end">
                    <Button onClick={() => modals.closeAll()}>Close</Button>
                </Flex>
            </Stack>
        )
    });

    return (
        <AppShell
            header={{ height: 50 }}
            padding="lg"
        >
            <AppShell.Header>
                <Box h="100%" data-tauri-drag-region>
                    <Flex justify="space-between" h="100%" w="100%" data-tauri-drag-region>
                        <Flex
                            h="100%"
                            w="100%"
                            justify="flex-start"
                            align="center"
                            style={{
                                userSelect: "none",
                            }}
                            data-tauri-drag-region>
                            <Group gap={6} ml={10}>
                                <IconVinyl />
                                <Text>Suno Music Downloader</Text>
                            </Group>
                        </Flex>
                        <CloseButton onClick={() => exit(1)} />
                    </Flex>
                </Box>
            </AppShell.Header>
            <AppShell.Main
                style={{
                    display: "flex",
                    flexDirection: "column", // Stacks children vertically
                    height: "100vh", // Full height of the viewport
                    overflow: "hidden", // Prevent overall layout overflow
                }}
            >
                {/* Top Section */}
                <SectionHeading number="1" title="Paste playlist link">
                    <Popover position="bottom-start" withArrow shadow="lg">
                        <Popover.Target>
                            <ActionIcon variant="subtle" size="sm" color="gray"><IconHelpCircle /></ActionIcon>
                        </Popover.Target>
                        <Popover.Dropdown>
                            <Group w={240} gap={4}>
                                <Image radius="md" src="./assets/copy-playlist.png" />
                                <Text>Navigate to your Suno playlist, and click the 'Copy playlist' button as shown</Text>
                            </Group>
                        </Popover.Dropdown>
                    </Popover>
                </SectionHeading>
                <Flex gap="sm" direction="row" mb={20}>
                    <TextInput
                        flex={1}
                        value={playlistUrl}
                        onChange={(event) => setPlaylistUrl(event.currentTarget.value)}
                        rightSection={<IconLink />}
                        disabled={isGettingPlaylist || isDownloading}
                    />
                    <Button
                        variant="filled"
                        loading={isGettingPlaylist}
                        onClick={getPlaylist}
                        disabled={isGettingPlaylist || isDownloading}
                    >
                        Get playlist songs
                    </Button>
                </Flex>

                {/* Central Section */}
                <SectionHeading number="2" title="Review songs" />
                <Flex
                    bg="dark.8"
                    mb={20}
                    style={{
                        flex: 1, // This grows to occupy remaining space
                        overflowY: "auto", // Scrollable if content exceeds
                        padding: "1rem", // Optional padding
                        borderRadius: "0.5rem",
                        flexFlow: "column"
                    }}
                >
                    <Table verticalSpacing="sm" ref={songTable}>
                        <Table.Thead>
                            <Table.Tr>
                                <Table.Th>Img</Table.Th>
                                <Table.Th>Title</Table.Th>
                                <Table.Th style={{ textAlign: "right" }}>Length</Table.Th>
                                <Table.Th></Table.Th>
                            </Table.Tr>
                        </Table.Thead>
                        <Table.Tbody>
                            {playlistData && playlistClips?.map((clip) => (
                                <Table.Tr key={clip.id} data-id={`row-${clip.id}`}>
                                    <Table.Td w={50}>
                                        <Image radius="sm" w={40} fit="contain" src={clip.image_url} />
                                    </Table.Td>
                                    <Table.Td>
                                        <Stack gap={0}>
                                            <Group gap={0}>
                                                <Text
                                                    fw={800} size="md"
                                                // variant="gradient"
                                                // gradient={{ from: "grape", to: "teal", deg: 45 }}
                                                >
                                                    {clip.title}
                                                </Text>
                                                <Badge size="xs"
                                                    variant="gradient"

                                                    gradient={{ from: 'blue', to: 'cyan', deg: 90 }}
                                                    ml={6}
                                                >{clip.model_version}</Badge>
                                            </Group>
                                            <Text size="sm" c="dimmed" lineClamp={1}>{clip.tags}</Text>
                                        </Stack>
                                    </Table.Td>
                                    <Table.Td style={{ textAlign: "right" }}>
                                        <Text ff="monospace">
                                            {formatSecondsToTime(clip.duration)}
                                        </Text>
                                    </Table.Td>
                                    <Table.Td style={{ textAlign: "center" }}>
                                        <StatusIcon status={clip.status} />
                                    </Table.Td>
                                </Table.Tr>
                            ))}
                        </Table.Tbody>
                    </Table>
                </Flex>

                {/* Bottom Section */}
                <SectionHeading number="3" title="Select folder and download">
                    <Popover position="bottom-start" withArrow shadow="lg">
                        <Popover.Target>
                            <ActionIcon variant="subtle" size="sm" color="gray"><IconHelpCircle /></ActionIcon>
                        </Popover.Target>
                        <Popover.Dropdown w={240}>
                            <Text>
                                In the selected directory, a new folder will be created with the playlist name. This folder will contain the downloaded songs.
                            </Text>
                        </Popover.Dropdown>
                    </Popover>
                </SectionHeading>
                <Flex gap="sm" direction="row" mb={20}>

                    <TextInput
                        flex={1}
                        value={saveFolder}
                        disabled={isDownloading}
                        readOnly
                        onClick={selectOutputFolder}
                        leftSection={<IconFolderFilled />}
                        style={{
                            pointer: "cursor",
                        }}
                    />
                    <Button
                        variant="filled"
                        disabled={isGettingPlaylist || isDownloading || (!playlistData)}
                        loading={isDownloading}
                        onClick={downloadPlaylist}
                    >
                        Download songs
                    </Button>
                </Flex>

                <Footer
                    firstComponent={
                        <Group gap={6}>
                            <Button leftSection={<IconBrandGithub />} variant="subtle" size="xs" component="a" href="http://www.github.com" target="_blank">Open source</Button>
                            <Divider orientation="vertical" />
                            <Button leftSection={<IconCoffee />} variant="subtle" size="xs" component="a" href="https://ko-fi.com/drummer_si" target="_blank">Buy me a coffee</Button>
                        </Group>
                    }
                    secondComponent={
                        <Stack
                            w="100%"
                            h={140}
                            gap={4}
                            pb={10}
                            mt={-5}
                        >
                            <Flex>
                                <Text size="xs">{downloadPercentage}%</Text>
                            </Flex>
                            <Progress value={downloadPercentage} animated />
                        </Stack>
                    }
                    currentView={footerView}
                />
            </AppShell.Main>
        </AppShell >
    )
}

// function App2() {
//     const [greetMsg, setGreetMsg] = useState("");
//     const [name, setName] = useState("");

//     async function greet() {
//         // Learn more about Tauri commands at <https://tauri.app/develop/calling-rust/>
//         setGreetMsg(await invoke("greet", { name }));
//     }

//     async function download() {

//         const response = await fetch("<https://cdn1.suno.ai/2023b630-359f-4d44-9529-60c3b472c79a.mp3>", {
//             method: "GET",
//         });
//         if (response.status !== 200) {
//             throw new Error("Failed to fetch the file.");
//         }

//         const fileData = new Uint8Array(await response.arrayBuffer())
//         await writeFile('test.mp3', fileData, { baseDir: BaseDirectory.Desktop })

//         console.log("SAVED")

//         sendNotification({
//             title: "Song downloaded",
//             body: "Song downloaded successfully",
//         })

//         // const file = await create('test.mp3', { baseDir: BaseDirectory.Desktop })
//         // await file.write(response.arrayBuffer)
//         // await file.close()
//         // console.log(response)

//         // const response = await fetch("<https://cdn1.suno.ai/2023b630-359f-4d44-9529-60c3b472c79a.mp3>", {
//         //     method: "GET",
//         //     //responseType: "ArrayBuffer", // Use ArrayBuffer for binary files
//         // });

//         // if (!response.data) {
//         //     throw new Error("Failed to fetch the file.");
//         // }

//         // const savePath = await dialog.save({
//         //     title: "Save File As",
//         //     defaultPath: "downloaded_file", // Default filename
//         // });

//         // if (!savePath) {
//         //     console.log("Save operation cancelled.");
//         //     return;
//         // }

//         // Step 3: Write the file to the selected location
//         // const fileData = new Uint8Array(response.data); // Convert ArrayBuffer to Uint8Array
//         // await fs.writeBinaryFile(savePath, fileData);

//         //console.log(`File successfully saved to: ${savePath}`);

//     }

//     return (
//         <main className="container">
//             <h1>Welcome to Tauri + React</h1>

//             <div className="row">
//                 <a href="https://vitejs.dev" target="_blank">
//                     <img src="/vite.svg" className="logo vite" alt="Vite logo" />
//                 </a>
//                 <a href="https://tauri.app" target="_blank">
//                     <img src="/tauri.svg" className="logo tauri" alt="Tauri logo" />
//                 </a>
//                 <a href="https://reactjs.org" target="_blank">
//                     <img src={reactLogo} className="logo react" alt="React logo" />
//                 </a>
//             </div>
//             <p>Click on the Tauri, Vite, and React logos to learn more.</p>

//             <form
//                 className="row"
//                 onSubmit={(e) => {
//                     e.preventDefault();
//                     greet();
//                 }}
//             >
//                 <input
//                     id="greet-input"
//                     onChange={(e) => setName(e.currentTarget.value)}
//                     placeholder="Enter a name..."
//                 />
//                 <button type="submit">Greet</button>

//                 <button onClick={download}>DOWNLOAD</button>
//             </form>
//             <p>{greetMsg}</p>
//         </main>
//     );
// }

export default App;

================================================
File: DL3/src/main.tsx
================================================

import '@mantine/core/styles.css';
import '@mantine/notifications/styles.css'

import { MantineProvider, createTheme } from '@mantine/core';

import App from "./App";
import { ModalsProvider } from '@mantine/modals'
import { Notifications } from '@mantine/notifications'
import React from "react";
import ReactDOM from "react-dom/client";

const theme = createTheme({
    /** Put your mantine theme override here */
    primaryColor: "blue",
});

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
    <React.StrictMode>
        <MantineProvider theme={theme} forceColorScheme="dark">
            <ModalsProvider>
                <Notifications />
                <App />
            </ModalsProvider>
        </MantineProvider>
    </React.StrictMode>,
);

================================================
File: DL3/src/vite-env.d.ts
================================================

/// <reference types="vite/client" />

================================================
File: DL3/src/components/Footer.tsx
================================================

import { Box, Button, Divider, Flex, Group, Stack } from "@mantine/core"
import { FC, useEffect, useRef, useState } from "react"
import { IconBrandGithub, IconCoffee } from "@tabler/icons-react"

import { useScrollIntoView } from "@mantine/hooks"

interface Props {
    firstComponent: JSX.Element
    secondComponent: JSX.Element
    currentView: 1 | 2
}
const Footer: FC<Props> = (props) => {

    const { firstComponent, secondComponent, currentView } = props

    // Scroll hook
    const { targetRef: containerRef } = useScrollIntoView<HTMLDivElement>();


    // Handler to toggle scrolling
    // const toggleView = () => {
    //     const container = containerRef.current;
    //     if (!container) return;

    //     if (isFirstVisible) {
    //         container.scrollTo({
    //             top: container.offsetHeight, // Scroll to second div
    //             behavior: 'smooth',
    //         });
    //     } else {
    //         container.scrollTo({
    //             top: 0, // Scroll back to first div
    //             behavior: 'smooth',
    //         });
    //     }

    //     setIsFirstVisible((prev) => !prev);
    // };

    useEffect(() => {
        const container = containerRef.current
        if (!container) return

        const targetScrollTop = currentView === 1 ? 0 : container.offsetHeight
        //console.log("SCROLL TO", targetScrollTop)
        container.scrollTo({
            top: targetScrollTop,
            behavior: "smooth"
        })
    }, [currentView])


    return (
        <Box
            ref={containerRef}
            h={40}
            bg="dark.8"
            style={{
                overflow: "hidden", // Scrollable if content exceeds
                padding: "0.4rem", // Optional padding
                borderRadius: "0.5rem",
                flexFlow: "column"
            }}
        >
            <Stack>
                <Flex
                    //ref={firstDiv.targetRef}
                    justify="center"
                    wrap="nowrap"
                    align="center"
                >
                    {firstComponent}
                </Flex>
                <Flex
                    //ref={secondDiv.targetRef}
                    justify="center"
                    wrap="nowrap"
                    align="center"
                >
                    {secondComponent}
                </Flex>
            </Stack>
        </Box>
    )
}

export default Footer

================================================
File: DL3/src/components/SectionHeading.tsx
================================================

import { Badge, Group, Title } from "@mantine/core"

import { FC } from "react"

interface Props {
    number: string
    title: string
    children?: React.ReactNode
}
const SectionHeading: FC<Props> = (props) => {
    const { number, title, children } = props
    return (
        <Group pb={8} gap={8}>
            <Badge
                circle
                size="lg"
                variant="gradient"
                gradient={{ from: 'blue', to: 'cyan', deg: 90 }}
            >{number}</Badge>
            <Title order={4}>{title}</Title>
            {children}
        </Group>
    )
}

export default SectionHeading

================================================
File: DL3/src/components/StatusIcon.tsx
================================================

import { IconCheck, IconSquareRoundedCheckFilled, IconSquareRoundedXFilled } from "@tabler/icons-react"
import { Loader, Text } from "@mantine/core"

import { FC } from "react"
import { IPlaylistClipStatus } from "../services/Suno"

interface Props {
    status: IPlaylistClipStatus
}

const StatusIcon: FC<Props> = (props) => {
    const { status } = props
    switch (status) {
        case IPlaylistClipStatus.None:
            return null

        case IPlaylistClipStatus.Processing:
            return <Loader size="xs" />

        case IPlaylistClipStatus.Success:
            return <Text c="green" mt={6}>
                <IconSquareRoundedCheckFilled />
            </Text>

        case IPlaylistClipStatus.Error:
            return <Text c="red" mt={6}>
                <IconSquareRoundedXFilled />
            </Text>

        default:
            return null
    }
}

export default StatusIcon

================================================
File: DL3/src/services/RustFunctions.ts
================================================

import { invoke } from "@tauri-apps/api/core"

export async function addImageToMp3(mp3Path: string, imagePath: string): Promise<string> {
    try {
        const result = await invoke<string>("add_image_to_mp3", { mp3Path, imagePath });
        return result; // "Successfully added image to MP3 at ..."
    } catch (error) {
        console.error("Error adding image to MP3:", error);
        throw new Error(error as string);
    }
}

export async function deletePath(targetPath: string) {
    try {
        const result = await invoke<string>("delete_path", { targetPath });
        console.log(result); // "Directories ensured for path: ..."
    } catch (error) {
        console.error("Failed to delete path:", error);
    }
}

export async function ensureDir(dirPath: string) {
    try {
        const result = await invoke<string>("ensure_directory_exists", { dirPath });
        console.log(result); // "Directories ensured for path: ..."
    } catch (error) {
        console.error("Failed to create directories:", error);
    }
}

export async function writeFile(name: string, content: ArrayBuffer) {
    const uint8ArrayContent = new Uint8Array(content);
    try {
        const result = await invoke("write_file", { name, content: uint8ArrayContent });
        console.log(result); // On success, log the success message
    } catch (error) {
        console.error('Error:', error); // On failure, log the error message
    }
}

================================================
File: DL3/src/services/Suno.ts
================================================

export enum IPlaylistClipStatus {
    None,
    Processing,
    Success,
    Error
}

export interface IPlaylist {
    name: string
    image: string
    //clips: IPlaylistClip[] | undefined
}

export interface IPlaylistClip {
    id: string
    no: number
    title: string
    duration: number
    tags: string
    model_version: string
    audio_url: string
    video_url: string
    image_url: string
    image_large_url: string
    status: IPlaylistClipStatus
}

class Suno {

    static async getSongsFromPlayList(url: string): Promise<[IPlaylist, IPlaylistClip[]]> {

        //TODO: Check we're in format: https://suno.com/playlist/8ebe794f-d640-46b6-bde8-121622e1a4c2 (https://suno.com/playlist/liked not supported)
        //Scrape URL: https://studio-api.prod.suno.com/api/playlist/8ebe794f-d640-46b6-bde8-121622e1a4c2/?page=1

        // ─── Extract Playlist Id ─────────────────────────────────────
        const regex = /suno\.com\/playlist\/(.*)/
        const match = url.match(regex)
        let playlistId = ""

        if (match && match[1]) {
            playlistId = match[1]
        } else {
            throw new Error("Invalid URL or no playlist ID found")
        }

        // ─── Fetch Playlist Data ─────────────────────────────────────
        let currentPage = 1
        let songNo = 1
        let endOfPlaylist = false

        let playlistName = ""
        let playListImage = ""
        const clips: IPlaylistClip[] = []

        while (!endOfPlaylist) {
            const response = await fetch(`https://studio-api.prod.suno.com/api/playlist/${playlistId}/?page=${currentPage}`)

            if (response.status !== 200) {
                throw new Error("Failed to fetch playlist data")
            }

            const data = await response.json()
            if (data.playlist_clips.length == 0) {
                endOfPlaylist = true
            } else {
                playlistName = data.name
                playListImage = data.image_url

                data.playlist_clips.forEach(({ clip }: any) => {
                    const itemData: IPlaylistClip = {
                        id: clip.id,
                        no: songNo,
                        title: clip.title,
                        duration: clip.metadata.duration,
                        tags: clip.metadata.tags,
                        model_version: clip.major_model_version,
                        audio_url: clip.audio_url,
                        video_url: clip.video_url,
                        image_url: clip.image_url,
                        image_large_url: clip.image_large_url,
                        status: IPlaylistClipStatus.None
                    }
                    clips.push(itemData)
                    songNo++
                })
            }
            currentPage++
        }

        return [
            {
                name: playlistName,
                image: playListImage
            },
            clips
        ]
    }

}

export default Suno

================================================
File: DL3/src/services/Utils.ts
================================================

import classes from "../styles/notifications.module.css";
import { notifications } from "@mantine/notifications";

export const stringToArrayBuffer = (str: string) => {
    // Convert the string to a Uint8Array
    const encoder = new TextEncoder();
    const uint8Array = encoder.encode(str);

    // Return the underlying ArrayBuffer
    return uint8Array.buffer;
}

export const delay = (ms: number): Promise<void> => {
    return new Promise((resolve) => setTimeout(resolve, ms));
}

export const showError = (message: string, title?: string) => {
    notifications.show({
        color: "red",
        title: title || "An error occured",
        message: message,
        position: "bottom-center",
        classNames: classes
    })
}

export const showSuccess = (message: string, title?: string) => {
    notifications.show({
        color: "green",
        title: title || "Success",
        message: message,
        position: "bottom-center",
        classNames: classes
    })
}

export const getRandomBetween = (min: number, max: number) => {
    return Math.random() * (max - min) + min
}

================================================
File: DL3/src/styles/notifications.module.css
================================================

.root {
  background-color: var(--notification-color, var(--mantine-primary-color-filled));

  &::before {
    background-color: var(--mantine-color-white);
  }
}

.description,
.title {
  color: var(--mantine-color-white);
}

.closeButton {
  color: var(--mantine-color-white);

  @mixin hover {
    background-color: rgba(0, 0, 0, 0.1);
  }
}

================================================
File: DL3/src-tauri/Cargo.toml
================================================

[package]
name = "suno-downloader"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
edition = "2021"

# See more keys and their definitions at <https://doc.rust-lang.org/cargo/reference/manifest.html>

[lib]

# The `_lib` suffix may seem redundant but it is necessary

# to make the lib name unique and wouldn't conflict with the bin name

# This seems to be only an issue on Windows, see <https://github.com/rust-lang/cargo/issues/8519>

name = "suno_downloader_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tauri-plugin-dialog = "2"
tauri-plugin-http = "2"
tauri-plugin-fs = "2"
tauri-plugin-clipboard-manager = "2.2.0"
tauri-plugin-notification = "2"
tauri-plugin-log = "2"
id3 = "0.4"
tauri-plugin-process = "2"

================================================
File: DL3/src-tauri/build.rs
================================================

fn main() {
    tauri_build::build()
}

================================================
File: DL3/src-tauri/.gitignore
================================================

# Generated by Cargo

# will have compiled files and executables

/target/

# Generated by Tauri

# will have schema files for capabilities auto-completion

/gen/schemas

================================================
File: DL3/src-tauri/src/lib.rs
================================================

// Learn more about Tauri commands at <https://tauri.app/develop/calling-rust/>

use std::fs;
use std::path::Path;

use id3::frame::Content;
use id3::frame::Frame;
use id3::frame::Picture;
use id3::frame::PictureType;
use id3::{Tag, Version};

# [tauri::command]
fn write_file(name: String, content: Vec<u8>) -> Result<String, String> {
    match fs::write(&name, content) {
        Ok(_) => Ok(format!("File written successfully to {}", name)),
        Err(e) => Err(format!("Failed to write file: {}", e)),
    }
}

# [tauri::command]
fn ensure_directory_exists(dir_path: String) -> Result<String, String> {
    let path = Path::new(&dir_path);

    //Attempt to create the directories if they don't exist
    if let Err(e) = fs::create_dir_all(path) {
        return Err(format!("Failed to create directories: {}", e));
    }

    Ok(format!("Directories ensured for path: {}", dir_path))
}

# [tauri::command]
fn delete_path(target_path: String) -> Result<String, String> {
    let path = Path::new(&target_path);

    if !path.exists() {
        return Ok(format!("Path does not exist. Nothing to do"));
    }

    //Attempt to remove file or directory
    if path.is_file() {
        fs::remove_file(path).map_err(|e| format!("Failed to delete file: {}", e))?;
    } else if path.is_dir() {
        fs::remove_dir_all(path).map_err(|e| format!("Failed to delete directory: {}", e))?;
    } else {
        return Err(format!("Unknown path type: {}", target_path));
    }

    return Ok(format!("Successfully deleted: {}", target_path));
}

# [tauri::command]
fn add_image_to_mp3(mp3_path: String, image_path: String) -> Result<String, String> {
    // Load the MP3 file's ID3 tag or create a new one if it doesn't exist
    let mut tag = Tag::read_from_path(&mp3_path).unwrap_or_else(|_| Tag::new());

    // Read the image data
    let image_data =
        fs::read(&image_path).map_err(|e| format!("Failed to read image file: {}", e))?;

    // Create a Picture frame for the image
    let picture = Picture {
        mime_type: "image/jpeg".to_string(), // Or "image/png" depending on your image format
        picture_type: PictureType::CoverFront, // This indicates it's a front cover
        description: String::from("Cover Art"), // Optional description
        data: image_data,                    // The image data
    };

    // Convert Picture to Frame
    let frame = Frame::with_content("APIC", Content::Picture(picture));

    // Add the picture frame to the tag
    tag.add_frame(frame);

    // Write the updated tag back to the MP3 file
    tag.write_to_path(&mp3_path, Version::Id3v24)
        .map_err(|e| format!("Failed to write ID3 tag: {}", e))?;

    Ok(format!("Successfully added image to MP3 at {}", mp3_path))
}

// #[tauri::command]
// fn greet(name: &str) -> String {
//     format!("Hello, {}! You've been greeted from Rust!", name)
// }

# [cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_process::init())
        .plugin(tauri_plugin_log::Builder::new().build())
        .plugin(tauri_plugin_notification::init())
        .plugin(tauri_plugin_clipboard_manager::init())
        .plugin(tauri_plugin_fs::init())
        .plugin(tauri_plugin_http::init())
        .plugin(tauri_plugin_dialog::init())
        .plugin(tauri_plugin_opener::init())
        .invoke_handler(tauri::generate_handler![
            add_image_to_mp3,
            ensure_directory_exists,
            delete_path,
            write_file,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

================================================
File: DL3/src-tauri/src/main.rs
================================================

// Prevents additional console window on Windows in release, DO NOT REMOVE!!
# ![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    suno_downloader_lib::run()
}

================================================
File: DL4/README.md
================================================

# Suno AI Media Downloader

This script is designed to download media from Suno AI, specifically audio, images, and video. The script can extract metadata from the media, estimate the BPM (beats per minute) of the audio file, and tag the downloaded MP3 file with the relevant information.

## Required Packages

To run the script, you need to install the following Python packages. You can install them using `pip`:

```bash
pip install requests mutagen librosa argparse
```

## Features

- __Download Audio, Images, Videos, and Data__: The script can download data, audio, images, and videos from the specified Suno AI URLs.
- __Estimate BPM__: The script uses the `librosa` library to estimate the BPM of the downloaded audio file.
- __ID3 Tagging__: The script uses `mutagen` to tag the downloaded MP3 files with the title, artist, album, and other relevant metadata.
- __Directory Structure__: By default, the script saves the downloaded files in a `downloads` directory. You can specify a different directory using the `-cd` argument.
- __Automatic Filename and Directory Cleaning__: The script automatically removes illegal characters from filenames and directory names to ensure compatibility across different operating systems (Windows, Mac, Linux).

## Usage

### Command-Line Arguments

- `-u, --url`: Suno Song URL(s), comma-separated. If not provided, the script will prompt you to paste the URL.
- `-s, --suno_id`: Suno Song ID(s), comma-separated.
- `-a, --audio`: Download audio and cover image.
- `-v, --video`: Download video only.
- `-i, --image`: Download image only.
- `-d, --data`: Print JSON data.
- `-l, --list`: Path to a file containing a list of Suno Song URLs.
- `-f, --force`: Overwrite existing files.
- `-cd, --change_directory`: Directory to save downloads, default is `downloads`.
- `-sr, --save_response`: Save raw response to a file.

### Examples

1. __Download a single Suno AI song:__

    ```bash
    python get_suno.py -u https://suno.com/song/example-id
    ```

2. __Download multiple Suno AI songs using a comma-separated list of URLs:__

    ```bash
    python get_suno.py -u "https://suno.com/song/example-id1,https://suno.com/song/example-id2"
    ```

3. __Download audio and cover image only:__

    ```bash
    python get_suno.py -a -u "https://suno.com/song/example-id"
    ```

4. __Download all content (audio, image, video) for a list of Suno AI song URLs from a file:__

    ```bash
    python get_suno.py -l urls.txt
    ```

5. __Save the downloaded files to a specific directory:__

    ```bash
    python get_suno.py -cd "my custom_directory" -u "https://suno.com/song/example-id"
    ```

### Default Behavior

If no arguments are provided, the script will prompt you to paste the Suno AI song URL.

## Notes

- The script will automatically create a directory based on the artist's name to save the downloaded content.
- Illegal characters in filenames and directories will be automatically replaced with underscores to ensure compatibility across operating systems.

================================================
File: DL4/get_suno.py
================================================

import os
import re
import json
import requests
import argparse
from mutagen.easyid3 import EasyID3
from mutagen.id3 import ID3, APIC, USLT, COMM, TXXX, TBPM
import librosa
import platform

def extract_script_content(html):
    pattern = r'<script>\s*self\.__next_f\.push\(\[.*?,"(.*?)"\]\s*\)</script>'
    matches = re.findall(pattern, html, re.DOTALL)
    unified_content = ''.join(matches).replace(r'\"', '"').replace(r'\\n', '\n').replace(r'\\t', '\t')
    # Decode all UTF-8 encoded sequences
    unified_content = unified_content.encode().decode('unicode_escape')
    return unified_content

def extract_json(unified_content):
    # Extract the main JSON block
    main_pattern = r'{"clip":{.*?}}'
    main_match = re.search(main_pattern, unified_content, re.DOTALL)
    if main_match:
        json_str = main_match.group(0)

        try:
            json_data = json.loads(json_str)
        except json.JSONDecodeError:
            # Attempt to clean the JSON string and retry
            json_str_cleaned = re.sub(r'[\x00-\x1f\x7f]', '', json_str)
            try:
                json_data = json.loads(json_str_cleaned)
            except json.JSONDecodeError as e:
                print(f"Failed to parse JSON after cleaning: {e}")
                return None
    else:
        json_data = None

    # Extract the additional JSON-like structures
    additional_pattern = r'\d+:\[\["\$".*?\]\]|\d+:[null,.*?]'
    matches = re.findall(additional_pattern, unified_content, re.DOTALL)

    additional_data = {}
    for match in matches:
        try:
            key, value = match.split(":", 1)
            value = json.loads(value)

            if isinstance(value, list):
                for item in value:
                    if isinstance(item, list) and len(item) == 4:
                        inner_key = item[3].get("name") or item[3].get("property")
                        if inner_key:
                            additional_data[inner_key] = item[3].get("content", '').strip()
                        elif item[2] == "children":
                            additional_data["children"] = item[3].get("children", '').strip()
            elif isinstance(value, dict):
                additional_data.update(value)

        except (json.JSONDecodeError, ValueError):
            continue  # Skip any lines that can't be converted to JSON

    if json_data:
        # Check if 'prompt' is $16, replace it with 'lyrics' value if it exists
        prompt = json_data['clip']['metadata'].get('prompt', '').strip()
        lyrics = extract_lyrics(unified_content)  # Extract the lyrics from the unified content
        if prompt == '$16' and lyrics:
            json_data['clip']['metadata']['prompt'] = lyrics.strip()

        # Strip spaces from all string values in json_data
        def strip_spaces(obj):
            if isinstance(obj, dict):
                return {k: strip_spaces(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [strip_spaces(elem) for elem in obj]
            elif isinstance(obj, str):
                return obj.strip()
            else:
                return obj

        # Apply space stripping to json_data and additional_data
        json_data = strip_spaces(json_data)
        additional_data = strip_spaces(additional_data)

        # Add the additional data at the end of the 'clip' object
        json_data['clip'].update(additional_data)

    return json_data

def extract_lyrics(unified_content):
    # Adjust the pattern to capture any text, including special characters, between '16:T' and '6:["$'
    lyrics_pattern = r'16:T[0-9a-f]+,(.*?)6:\["\$"'

    # Use re.DOTALL to make sure that the pattern matches across multiple lines
    match = re.search(lyrics_pattern, unified_content, re.DOTALL)

    if match:
        lyrics = match.group(1).strip()  # Use .strip() to clean up any leading/trailing whitespace
        return lyrics.replace(r'\\n', '\n').replace(r'\n', '\n')  # Properly format newlines
    return None

def download_file(url, filename):
    response = requests.get(url, timeout=30)
    with open(filename, 'wb') as file:
        file.write(response.content)

def tag_mp3_file(mp3_filename, clip, image_filename, bpm, url):
    audio = EasyID3(mp3_filename)
    audio['title'] = clip['title']
    audio['artist'] = clip['display_name']
    audio['album'] = 'Suno AI Music'
    audio['date'] = clip['created_at'].split['T'](0)
    audio['genre'] = 'SunoAI'
    audio['catalognumber'] = clip['id']
    audio['mood'] = clip['metadata']['tags']
    audio.save()

    audio = ID3(mp3_filename)
    prompt = clip['metadata'].get('prompt', '')

    audio['USLT'] = USLT(encoding=3, lang='eng', desc='', text=prompt.replace('\\n', '\n'))
    formatted_bpm = f"{bpm:.3f}"  # Ensure the BPM is formatted to three decimal places
    audio['TXXX:BPM Precise'] = TXXX(encoding=3, desc='BPM Precise', text=formatted_bpm)

    # Add a comment with Suno URL, Style, and BPM
    comment_text = f"Suno URL: {url}\nStyle: {clip['metadata'].get('tags', 'N/A')}\nBPM: {clip['metadata'].get('estimated_bpm', 'N/A')}"
    audio['COMM'] = COMM(encoding=3, lang='eng', desc='', text=comment_text)

    if 'tags' in clip['metadata']:
        audio['COMM::tags'] = COMM(encoding=3, lang='eng', desc='tags', text=clip['metadata']['tags'])
    if image_filename:
        with open(image_filename, 'rb') as img_file:
            audio['APIC'] = APIC(
                encoding=3,
                mime='image/jpeg',
                type=3,
                desc='Cover',
                data=img_file.read()
            )
    audio.save()

def estimate_bpm(mp3_filename):
    y, sr = librosa.load(mp3_filename)
    tempo,_ = librosa.beat.beat_track(y=y, sr=sr)
    return float(tempo) if tempo.ndim == 0 else float(tempo[0])  # Ensure the tempo is a float

def clean_filename(filename):
    # Define illegal characters based on OS
    illegal_chars = {
        'Windows': r'[<>:"/\\|?*]',
        'Linux': r'[\\/\x00]',
        'Darwin': r'[\\/:]',
    }

    os_type = platform.system()  # Get the current OS type
    pattern = illegal_chars.get(os_type, r'[<>:"/\\|?*]')  # Default to Windows pattern

    # Clean the filename by replacing illegal characters with an underscore
    return re.sub(pattern, '_', filename)

def main():
    print(f"{'='*50}\n{' '*15}Suno AI Media Downloader\n{'='*50}\n")
    parser = argparse.ArgumentParser(description="Download media from Suno AI.")
    parser.add_argument("-u", "--url", help="Suno Song URL(s), comma-separated")
    parser.add_argument("-s", "--suno_id", help="Suno Song ID(s), comma-separated")
    parser.add_argument("-a", "--audio", action="store_true", help="Download audio and cover image")
    parser.add_argument("-v", "--video", action="store_true", help="Download video only")
    parser.add_argument("-i", "--image", action="store_true", help="Download image only")
    parser.add_argument("-d", "--data", action="store_true", help="Print JSON data")
    parser.add_argument("-l", "--list", help="Path to a file containing a list of Suno Song URLs")
    parser.add_argument("-f", "--force", action="store_true", help="Overwrite existing files")
    parser.add_argument("-cd", "--change_directory", default="downloads", help="Directory to save downloads, default is 'downloads'")
    parser.add_argument("-sr", "--save_response", action="store_true", help="Save raw response to file")

    args = parser.parse_args()

    # Use the specified directory or default to 'downloads'
    download_dir = args.change_directory

    if not os.path.exists(download_dir):
        os.makedirs(download_dir)

    urls = []
    if args.list:
        with open(args.list, 'r') as file:
            urls = [line.strip() for line in file.readlines()]
    elif args.url:
        urls.extend(args.url.split(','))
    elif args.suno_id:
        urls.extend([f"https://suno.com/song/{id.strip()}" for id in args.suno_id.split(',')])
    else:
        urls.append(input("Enter Suno Song URL: "))

    for url in urls:
        if not url.strip():
            print("That is not a valid url.")
            continue
        if "suno.com" not in url:
            print("That is not a Suno url.")
            continue

        response = requests.get(url, timeout=30)
        if response.status_code == 200:
            script_content = extract_script_content(response.text)
            json_data = extract_json(script_content)
            if not json_data:
                print(f"Failed to extract JSON data from URL: {url}")
                continue

            clip = json_data['clip']

            # Set the directory for downloads based on clip display name
            final_download_dir = os.path.join(download_dir, clean_filename(clip['display_name']))
            if not os.path.exists(final_download_dir):
                os.makedirs(final_download_dir)

            # Ensure BPM is estimated before setting the filename
            audio_url = clip['audio_url']
            audio_filename_temp = os.path.join(final_download_dir, 'temp_audio.mp3')
            download_file(audio_url, audio_filename_temp)
            bpm = estimate_bpm(audio_filename_temp)
            os.remove(audio_filename_temp)

            # Add the estimated BPM to the metadata
            json_data['clip']['metadata']['estimated_bpm'] = f"{bpm:.3f} BPM"

            base_filename = clean_filename(f"{clip['display_name']} - {clip['title']} {{id-{clip['id']}}}")
            base_filename = re.sub(r'[<>:"/\\|?*]', '', base_filename.replace('\\n', '').replace('\n', ''))

            # Add the Suno song URL to the JSON data
            final_json_data = {"suno_song_url": url, "clip": clip}

            json_filename = os.path.join(final_download_dir, f"{base_filename}.json")
            if not os.path.exists(json_filename) or args.force:
                with open(json_filename, 'w', encoding='utf-8') as json_file:
                    json.dump(final_json_data, json_file, indent=4)
            else:
                print(f"Json Exists - Skipping id: {clip['id']}")

            if args.data:
                print(json.dumps(final_json_data, indent=4))

            # Save raw response if requested
            if args.save_response:
                response_filename = os.path.join(final_download_dir, f"{base_filename}-response.txt")
                with open(response_filename, 'w', encoding='utf-8') as response_file:
                    response_file.write(script_content)

            image_filename = None
            # Ensure image is downloaded when audio is selected
            if args.audio or args.image:
                image_url = clip['image_large_url']
                image_filename = os.path.join(final_download_dir, f"{base_filename}.jpeg")
                if not os.path.exists(image_filename) or args.force:
                    print(f"Downloading {image_url}...")
                    download_file(image_url, image_filename)
                    print(f"    Downloaded: {base_filename}.jpeg\n")
                else:
                    print(f"Image Exists - Skipping id: {clip['id']}")

            if args.audio or args.video:
                if args.audio:
                    audio_filename = os.path.join(final_download_dir, f"{base_filename}.mp3")
                    if not os.path.exists(audio_filename) or args.force:
                        print(f"Downloading {audio_url}...")
                        download_file(audio_url, audio_filename)
                        print(f"    Downloaded: {base_filename}.mp3")
                        print(f"    Detecting BPM for {base_filename}.mp3")
                        print(f"        Estimated BPM: {bpm:.3f}")
                        print(f"    Writing ID3 Tags on: {base_filename}.mp3")
                        tag_mp3_file(audio_filename, clip, image_filename, bpm, url)
                    else:
                        print(f"Audio Exists - Skipping id: {clip['id']}")

                if args.video:
                    video_url = clip['video_url']
                    video_filename = os.path.join(final_download_dir, f"{base_filename}.mp4")
                    if not os.path.exists(video_filename) or args.force:
                        print(f"Downloading {video_url}...")
                        download_file(video_url, video_filename)
                        print(f"    Downloaded: {base_filename}.mp4\n")
                    else:
                        print(f"Video Exists - Skipping id: {clip['id']}")
            else:  # Default behavior without specific args
                image_url = clip['image_large_url']
                image_filename = os.path.join(final_download_dir, f"{base_filename}.jpeg")
                if not os.path.exists(image_filename) or args.force:
                    print(f"Downloading {image_url}...")
                    download_file(image_url, image_filename)
                    print(f"    Downloaded: {base_filename}.jpeg\n")
                else:
                    print(f"Image Exists - Skipping id: {clip['id']}")

                audio_filename = os.path.join(final_download_dir, f"{base_filename}.mp3")
                if not os.path.exists(audio_filename) or args.force:
                    print(f"Downloading {audio_url}...")
                    download_file(audio_url, audio_filename)
                    print(f"    Downloaded: {base_filename}.mp3")
                    print(f"    Detecting BPM for {base_filename}.mp3")
                    print(f"        Estimated BPM: {bpm:.3f}")
                    print(f"    Writing ID3 Tags on: {base_filename}.mp3")
                    tag_mp3_file(audio_filename, clip, image_filename, bpm, url)
                else:
                    print(f"Audio Exists - Skipping id: {clip['id']}")

                video_url = clip['video_url']
                video_filename = os.path.join(final_download_dir, f"{base_filename}.mp4")
                if not os.path.exists(video_filename) or args.force:
                    print(f"Downloading {video_url}...")
                    download_file(video_url, video_filename)
                    print(f"    Downloaded: {base_filename}.mp4\n")
                else:
                    print(f"Video Exists - Skipping id: {clip['id']}")
        else:
            print(f"Failed to fetch the URL: {response.status_code}")

if __name__ == "__main__":
    main()

================================================
File: SunoURLS/sunoGFT.py
================================================

import requests
from bs4 import BeautifulSoup
import argparse

def extract_song_links_from_playlist(playlist_url):
    """
    Extracts song links from a public SunoAI playlist URL.

    Args:
        playlist_url (str): The URL of the public SunoAI playlist.

    Returns:
        list: A list of song URLs extracted from the playlist, or None if an error occurs.
    """
    try:
        response = requests.get(playlist_url)
        response.raise_for_status()  # Raise an exception for HTTP errors

        soup = BeautifulSoup(response.content, 'html.parser')

        song_links = []
        # Inspecting SunoAI playlist page, song links are typically in 'a' tags
        # that have href attributes starting with '/song/' and are within a specific section.
        # Let's try a general approach to find all such links first.
        for link_tag in soup.find_all('a', href=True):
            href = link_tag['href']
            if href.startswith('/song/'):
                full_song_link = f"https://suno.com{href}"
                song_links.append(full_song_link)

        # Remove duplicate links if any and return the unique song links
        return list(set(song_links))

    except requests.exceptions.RequestException as e:
        print(f"Error fetching playlist URL: {e}")
        return None
    except Exception as e:
        print(f"Error parsing playlist page: {e}")
        return None

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Extract song links from a public SunoAI playlist.")
    parser.add_argument("playlist_url", help="The public SunoAI playlist URL")

    args = parser.parse_args()
    playlist_url = args.playlist_url

    if not playlist_url.startswith("https://suno.com/playlist/"):
        print("Error: Please provide a valid SunoAI playlist URL that starts with 'https://suno.com/playlist/'")
    else:
        song_links = extract_song_links_from_playlist(playlist_url)

        if song_links:
            print("\nExtracted Song Links from the Playlist:")
            for link in song_links:
                print(link)
        else:
            print("No song links found or an error occurred.")

================================================
File: SunoURLS/sunoGPX.js
================================================

import puppeteer from 'puppeteer';
import * as fs from 'fs/promises';

async function extractPlaylistSongs(playlistUrl) {
    const browser = await puppeteer.launch({ headless: "new" });
    const page = await browser.newPage();

    try {
        await page.goto(playlistUrl, { waitUntil: 'networkidle2' });

        // Extract total number of songs
        const totalSongsText = await page.$eval('div.line-clamp-1.text-ellipsis.overflow-hidden.w-fit', el => el.textContent);
        const totalSongsMatch = totalSongsText.match(/(\d+)\s+songs/);
        let totalSongs = 0;
        if (totalSongsMatch) {
            totalSongs = parseInt(totalSongsMatch[1], 10);
        } else {
            console.warn("Could not find total song count. Continuing anyway.");
        }

        // Robust Scrolling with Delay (using Promise-based delay)
        let previousHeight;
        let attempts = 0;
        const maxAttempts = 20; // Limit scroll attempts
        const scrollDelay = 1500; // milliseconds to wait AFTER scrolling

        while (attempts < maxAttempts) {
            previousHeight = await page.evaluate('document.body.scrollHeight');
            await page.evaluate('window.scrollTo(0, document.body.scrollHeight)');
            await new Promise(resolve => setTimeout(resolve, scrollDelay)); // Correct delay

            try {
                await page.waitForFunction(`document.body.scrollHeight > ${previousHeight}`, { timeout: 10000 });
                attempts = 0;
            } catch (e) {
                attempts++;
            }
        }
        console.log("Finished Scrolling");

        // Extract song URLs, filtering out those with "?show_comments=true"
        await page.waitForSelector('a[href^="/song/"]');
        const songLinks = await page.$$eval('a[href^="/song/"]', links =>
            links.map(a => a.getAttribute('href'))
                .filter(href => !href.includes('?show_comments=true'))
                .map(href => `https://suno.com${href}`)
        );

        const uniqueSongLinks = [...new Set(songLinks)]; // Remove Duplicates
        if (uniqueSongLinks.length !== totalSongs) {
            console.warn(`Extracted ${uniqueSongLinks.length} song URLs, but expected ${totalSongs}. There may be missing songs.`);
        }

        await browser.close();
        return uniqueSongLinks;

    } catch (error) {
        console.error("Error fetching or processing playlist:", error, error.stack);
        await browser.close();
        return [];
    }
}

async function main() {
    const playlistUrl = process.argv[2];

    if (!playlistUrl) {
        console.error("Please provide a Suno playlist URL as a command-line argument.");
        return;
    }
    if (!playlistUrl.includes("suno.com/playlist/")) {
        console.error("Invalid playlist URL.  Must be a suno.com/playlist/ URL");
        return;
    }

    const songUrls = await extractPlaylistSongs(playlistUrl);

    if (songUrls.length > 0) {
        const outputString = songUrls.join(' ');
        try {
            await fs.writeFile('url.txt', outputString);
            console.log("Song URLs written to url.txt");
        } catch (err) {
            console.error("Error writing to file:", err);
        }
    } else {
        console.log("No song URLs found in the playlist.");
    }
}

main();

================================================
File: SunoURLS/sunoREADME.md
================================================

# SunoGFT.py

__How to use the script:__

1. __Save the code:__ Save the above code as a Python file, for example, `extract_playlist_links.py`.
2. __Run from the command line:__

    ```bash
    python sunoGFT.py <YOUR_SUNO_PLAYLIST_URL>
    ```

    Replace `<YOUR_SUNO_PLAYLIST_URL>` with the actual URL of the public SunoAI playlist you want to extract links from. For example:

    ```bash
    python sunoGFT.py https://suno.com/playlist/ccc8a381-0fe4-42cf-bf6a-893624ead57e
    ```

# SunoGPX.js

How to run the script:

1. __Install Node.js:__ Make sure you have Node.js and npm (Node Package Manager) installed on your system.
2. __Save the script:__ Save the code above as a `.js` file (e.g., `extract_suno_playlist.js`).
3. __Install dependencies:__ Open a terminal or command prompt in the directory where you saved the script and run:

    ```bash
    npm install axios cheerio
    ```

4. __Run the script:__  Provide the Suno playlist URL as a command-line argument:

    ```bash
    node sunoGPX.js "https://suno.com/playlist/ccc8a381-0fe4-42cf-bf6a-893624ead57e"
    ```

    Replace `"https://suno.com/playlist/ccc8a381-0fe4-42cf-bf6a-893624ead57e"` with the actual URL of the public Suno playlist.

The script will print the extracted song URLs to the console.  If there's an error, it will print an error message.
